package postgres

import (
    "time"

	"github.com/dairycart/dairycart/api/storage/models"
)

{{- $modelName := pascal (trimSuffix .Table.Name "s") }}
{{- $shortVarName := toLower (sliceString $modelName 0 1) }}
{{- $isProduct := eq $modelName "Product" }}
{{- $isDiscount := eq $modelName "Discount" }}

{{- if $isProduct }}
{{ $bySKUVarName := printf "%sQueryBySKU" ( camel $modelName ) -}}
const {{ $bySKUVarName }} = `
    SELECT
    {{ $lastCol := dec (len .Table.Columns.DBNames) -}}
    {{ range $x, $col := .Table.Columns.DBNames }}    {{ $col }}{{ if ne $x $lastCol }},
    {{ end }}{{ end }}
    FROM
        {{ .Table.Name }}
    WHERE
        archived_on is null
    AND
        sku = $1
`

func (pg *Postgres) Get{{ $modelName }}BySKU(sku string) (*models.{{ $modelName }}, error) {
	{{ $shortVarName }} := &models.{{ $modelName }}{}

    err := pg.DB.QueryRow({{ $bySKUVarName }}, sku).Scan({{ $lastCol := dec (len .Table.Columns.DBNames) -}}{{ range $x, $col := .Table.Columns.DBNames }}&{{ $shortVarName }}.{{ if or (eq (toLower $col) "sku") (eq (toLower $col) "upc") }}{{ toUpper $col }}{{ else }}{{ pascal $col }}{{ end }}{{ if ne $x $lastCol }}, {{ end }}{{ end }})

	return {{ $shortVarName }}, err
}
{{- end }}

{{- if $isDiscount }}
{{ $byCodeVarName := printf "%sQueryByCode" ( camel $modelName ) -}}
const {{ $byCodeVarName }} = `
    SELECT
    {{ $lastCol := dec (len .Table.Columns.DBNames) -}}
    {{ range $x, $col := .Table.Columns.DBNames }}    {{ $col }}{{ if ne $x $lastCol }},
    {{ end }}{{ end }}
    FROM
        {{ .Table.Name }}
    WHERE
        archived_on is null
    AND
        sku = $1
`

func (pg *Postgres) Get{{ $modelName }}ByCode(code string) (*models.{{ $modelName }}, error) {
	{{ $shortVarName }} := &models.{{ $modelName }}{}

    err := pg.DB.QueryRow({{ $byCodeVarName }}, code).Scan({{ $lastCol := dec (len .Table.Columns.DBNames) -}}{{ range $x, $col := .Table.Columns.DBNames }}&{{ $shortVarName }}.{{ pascal $col }}{{ if ne $x $lastCol }}, {{ end }}{{ end }})
	return {{ $shortVarName }}, err
}
{{- end }}

{{ $readQueryVarName := printf "%sSelectionQuery" ( camel $modelName ) -}}
const {{ $readQueryVarName }} = `
    SELECT
    {{ $lastCol := dec (len .Table.Columns.DBNames) -}}
    {{ range $x, $col := .Table.Columns.DBNames }}    {{ $col }}{{ if ne $x $lastCol }},
    {{ end }}{{ end }}
    FROM
        {{ .Table.Name }}
    WHERE
        archived_on is null
    AND
        id = $1
`

func (pg *Postgres) Get{{ $modelName }}(id uint64) (*models.{{ $modelName }}, error) {
	{{ $shortVarName }} := &models.{{ $modelName }}{}

    err := pg.DB.QueryRow({{ $readQueryVarName }}, id).Scan({{ $lastCol := dec (len .Table.Columns.DBNames) -}}{{ range $x, $col := .Table.Columns.DBNames }}&{{ $shortVarName }}.{{ if or (eq (toLower $col) "sku") (eq (toLower $col) "upc") }}{{ toUpper $col }}{{ else }}{{ pascal $col }}{{ end }}{{ if ne $x $lastCol }},{{ end }}{{ end }})

	return {{ $shortVarName }}, err
}

{{ $creationColumns := .Table.Columns.Names.Except (makeSlice "id" "created_on" "archived_on" "updated_on") -}}
{{ $creationQueryVarName := printf "%sCreationQuery" ( toLower $modelName ) -}}
const {{ $creationQueryVarName }} = `
    INSERT INTO {{ .Table.Name }}
        (
            {{ $lastCol := dec (len $creationColumns) -}}
            {{ range $x, $col := $creationColumns -}}
            {{ $col }}{{ if ne $lastCol $x }}, {{ end }}{{ end }}
        )
    VALUES
        (
            {{ $lastCol := dec (len $creationColumns) -}}
            {{ range $x, $col := $creationColumns -}}
            ${{ inc $x }}{{ if ne $lastCol $x }}, {{ end }}{{ end }}
        )
    RETURNING
        id, created_on{{ if $isProduct }}, available_on{{ end }};
`

func (pg *Postgres) Create{{ $modelName }}(nu *models.{{ $modelName }}) (uint64, time.Time, {{- if $isProduct }}time.Time, {{ end }}error) {
    var (
        createdID uint64
        createdAt time.Time
        {{ if $isProduct -}}availableOn time.Time{{ end -}}
    )
    err := pg.DB.QueryRow({{ $creationQueryVarName }}, {{ range $x, $col := $creationColumns -}}&nu.{{- if and (ne $col "upc") (ne $col "sku") -}}{{ pascal $col -}}{{ else }}{{ toUpper $col }}{{ end }}{{ if ne $lastCol $x }}, {{ end }}{{ end }}).Scan(&createdID, &createdAt{{- if $isProduct }}, &availableOn{{ end }})

    return createdID, createdAt, {{- if $isProduct }}availableOn, {{ end }}err
}

{{ $updateColumns := .Table.Columns.Names.Except (makeSlice "id" "created_on" "archived_on") -}}
{{ $updateQueryVarName := printf "%sUpdateQuery" ( camel $modelName ) -}}
const {{ $updateQueryVarName }} = `
    UPDATE {{ toLower .Table.Name }}
    SET{{ $lastCol := dec (len $updateColumns) -}}
    {{ range $x, $col := $updateColumns }}
        {{ $col }} = {{ if eq $col "updated_on"}}NOW(){{ else }}${{ inc $x }}{{ if ne $x $lastCol }}, {{ end }}{{ end }}{{ end }}
    WHERE id = ${{ len $updateColumns }}
    RETURNING updated_on;
`

func (pg *Postgres) Update{{ $modelName }}(updated *models.{{ $modelName }}) (time.Time, error) {
    var t time.Time
	err := pg.DB.QueryRow({{ $updateQueryVarName }}, {{ $lastCol := dec (len $updateColumns) -}}{{ range $x, $col := $updateColumns }}{{ if and (ne $col "updated_on") (ne $col "id")}}&updated.{{ if or (eq (toLower $col) "sku") (eq (toLower $col) "upc") }}{{ toUpper $col }}{{ else }}{{ pascal $col }}{{ end }}, {{ end }}{{ end }}&updated.ID).Scan(&t)
    return t, err
}

{{ $deletionQueryVarName := printf "%sDeletionQuery" ( camel $modelName ) -}}
const {{ $deletionQueryVarName }} = `
    UPDATE {{ toLower .Table.Name }}
    SET archived_on = NOW()
    WHERE id = $1
    RETURNING archived_on
`

func (pg *Postgres) Delete{{ $modelName }}(id uint64) (time.Time, error) {
    var t time.Time
	err := pg.DB.QueryRow({{ $deletionQueryVarName }}, id).Scan(&t)
    return t, err
}
