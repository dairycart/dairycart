package postgres

{{- $modelName := pascal (trimSuffix .Table.Name "s")}}
{{- $isUser := eq $modelName "User" }}
{{- $isProduct := eq $modelName "Product" }}
{{- $isDiscount := eq $modelName "Discount" }}
{{- $isProductRoot := eq $modelName "ProductRoot" }}
{{- $isLoginAttempt := eq $modelName "LoginAttempt" }}
{{- $isProductVariantBridge := eq $modelName "ProductVariantBridge" }}

import(
    "database/sql"
    "database/sql/driver"
    "errors"
    "strconv"
    "testing"

    // internal dependencies
	"github.com/dairycart/dairycart/api/storage/models"

    // external dependencies
	"github.com/stretchr/testify/require"
	"gopkg.in/DATA-DOG/go-sqlmock.v1"
)

{{- $shortVarName := toLower (sliceString $modelName 0 1) }}
{{ $readQueryVarName := printf "%sSelectionQuery" ( camel $modelName ) -}}
{{ $creationQueryVarName := printf "%sCreationQuery" ( toLower $modelName ) -}}
{{ $updateQueryVarName := printf "%sUpdateQuery" ( camel $modelName ) -}}
{{ $deletionQueryVarName := printf "%sDeletionQuery" ( camel $modelName ) -}}

{{ if $isProduct }}
{{ $bySKUVarName := printf "%sQueryBySKU" ( camel $modelName ) -}}
func set{{ $modelName }}ReadQueryExpectationBySKU(t *testing.T, mock sqlmock.Sqlmock, sku string, toReturn *models.{{ $modelName }}, err error) {
    t.Helper()
    query := formatQueryForSQLMock({{ $bySKUVarName }})
    exampleRows := sqlmock.NewRows([]string{
        {{ range $_, $x := .Table.Columns.DBNames }}{{ printf "\"%s\"" $x }},
        {{ end }}
    }).AddRow(
        {{ range $_, $x := .Table.Columns.DBNames }}{{ if or (eq (toLower $x) "sku") (eq (toLower $x) "upc") }}toReturn.{{ toUpper $x }},{{ else }}toReturn.{{ pascal $x }},{{ end }}
        {{ end }}
    )
    mock.ExpectQuery(query).WithArgs(sku).WillReturnRows(exampleRows).WillReturnError(err)
}

func TestGet{{ $modelName }}BySKU(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    require.Nil(t, err)
    defer mockDB.Close()
    client := NewPostgres()

    exampleSKU := "hello"
    expected := &models.{{ $modelName }}{SKU: exampleSKU}

    t.Run("optimal behavior", func(t *testing.T) {
        set{{ $modelName }}ReadQueryExpectationBySKU(t, mock, exampleSKU, expected, nil)
        actual, err := client.Get{{ $modelName }}BySKU(mockDB, exampleSKU)

        require.Nil(t, err)
        require.Equal(t, expected, actual, "expected {{ toLower $modelName }} did not match actual {{ toLower $modelName }}")
        require.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}
{{ end }}

{{ if $isUser }}
{{ $byUsernameVarName := printf "%sQueryByUsername" ( camel $modelName ) -}}
func set{{ $modelName }}ReadQueryExpectationByUsername(t *testing.T, mock sqlmock.Sqlmock, username string, toReturn *models.{{ $modelName }}, err error) {
    t.Helper()
    query := formatQueryForSQLMock({{ $byUsernameVarName }})
    exampleRows := sqlmock.NewRows([]string{
        {{ range $_, $x := .Table.Columns.DBNames }}{{ printf "\"%s\"" $x }},
        {{ end }}
    }).AddRow(
        {{ range $_, $x := .Table.Columns.DBNames }}toReturn.{{ pascal $x }},
        {{ end }}
    )
    mock.ExpectQuery(query).WithArgs(username).WillReturnRows(exampleRows).WillReturnError(err)
}

func TestGet{{ $modelName }}ByUsername(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    require.Nil(t, err)
    defer mockDB.Close()
    client := NewPostgres()

    exampleUsername := "username"
    expected := &models.{{ $modelName }}{Username: exampleUsername}

    t.Run("optimal behavior", func(t *testing.T) {
        set{{ $modelName }}ReadQueryExpectationByUsername(t, mock, exampleUsername, expected, nil)
        actual, err := client.Get{{ $modelName }}ByUsername(mockDB, exampleUsername)

        require.Nil(t, err)
        require.Equal(t, expected, actual, "expected {{ toLower $modelName }} did not match actual {{ toLower $modelName }}")
        require.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}

{{ $existenceWithUsernameQueryVarName := printf "%sWithUsernameExistenceQuery" ( camel $modelName ) -}}
func set{{ $modelName }}WithUsernameExistenceQueryExpectation(t *testing.T, mock sqlmock.Sqlmock, username string, shouldExist bool, err error) {
    t.Helper()
    query := formatQueryForSQLMock({{ $existenceWithUsernameQueryVarName }})

	mock.ExpectQuery(query).
		WithArgs(username).
		WillReturnRows(sqlmock.NewRows([]string{""}).AddRow(strconv.FormatBool(shouldExist))).
		WillReturnError(err)
}

func Test{{ $modelName }}WithUsernameExists(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    require.Nil(t, err)
    defer mockDB.Close()
    exampleUsername := "username"
    client := NewPostgres()

    t.Run("existing", func(t *testing.T) {
        set{{ $modelName }}WithUsernameExistenceQueryExpectation(t, mock, exampleUsername, true, nil)
        actual, err := client.{{ $modelName }}WithUsernameExists(mockDB, exampleUsername)

        require.Nil(t, err)
        require.True(t, actual)
        require.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
    t.Run("with no rows found", func(t *testing.T) {
        set{{ $modelName }}WithUsernameExistenceQueryExpectation(t, mock, exampleUsername, true, sql.ErrNoRows)
        actual, err := client.{{ $modelName }}WithUsernameExists(mockDB, exampleUsername)

        require.Nil(t, err)
        require.False(t, actual)
        require.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
    t.Run("with a database error", func(t *testing.T) {
        set{{ $modelName }}WithUsernameExistenceQueryExpectation(t, mock, exampleUsername, true, errors.New("pineapple on pizza"))
        actual, err := client.{{ $modelName }}WithUsernameExists(mockDB, exampleUsername)

        require.NotNil(t, err)
        require.False(t, actual)
        require.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}
{{ end }}

{{ if $isDiscount }}
{{ $byCodeVarName := printf "%sQueryByCode" ( camel $modelName ) -}}
func set{{ $modelName }}ReadQueryExpectationByCode(t *testing.T, mock sqlmock.Sqlmock, code string, toReturn *models.{{ $modelName }}, err error) {
    t.Helper()
    query := formatQueryForSQLMock({{ $byCodeVarName }})

    exampleRows := sqlmock.NewRows([]string{
        {{ range $_, $x := .Table.Columns.DBNames }}{{ printf "\"%s\"" $x }},
        {{ end }}
    }).AddRow(
        {{ range $_, $x := .Table.Columns.DBNames }}{{ if or (eq (toLower $x) "sku") (eq (toLower $x) "upc") }}toReturn.{{ toUpper $x }},{{ else }}toReturn.{{ pascal $x }},{{ end }}
        {{ end }}
    )
    mock.ExpectQuery(query).WithArgs(code).WillReturnRows(exampleRows).WillReturnError(err)
}

func TestGet{{ $modelName }}ByCode(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    require.Nil(t, err)
    defer mockDB.Close()
    client := NewPostgres()

    exampleCode := "welcome"
    expected := &models.{{ $modelName }}{Code: exampleCode}

    t.Run("optimal behavior", func(t *testing.T) {
        set{{ $modelName }}ReadQueryExpectationByCode(t, mock, exampleCode, expected, nil)
        actual, err := client.Get{{ $modelName }}ByCode(mockDB, exampleCode)

        require.Nil(t, err)
        require.Equal(t, expected, actual, "expected {{ toLower $modelName }} did not match actual {{ toLower $modelName }}")
        require.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}
{{ end }}

{{- if $isProduct }}
{{ $existenceWithSKUQueryVarName := printf "%sWithSKUExistenceQuery" ( camel $modelName ) -}}
func set{{ $modelName }}WithSKUExistenceQueryExpectation(t *testing.T, mock sqlmock.Sqlmock, sku string, shouldExist bool, err error) {
    t.Helper()
    query := formatQueryForSQLMock({{ $existenceWithSKUQueryVarName }})

	mock.ExpectQuery(query).
		WithArgs(sku).
		WillReturnRows(sqlmock.NewRows([]string{""}).AddRow(strconv.FormatBool(shouldExist))).
		WillReturnError(err)
}

func Test{{ $modelName }}WithSKUExists(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    require.Nil(t, err)
    defer mockDB.Close()
    exampleSKU := "example"
    client := NewPostgres()

    t.Run("existing", func(t *testing.T) {
        set{{ $modelName }}WithSKUExistenceQueryExpectation(t, mock, exampleSKU, true, nil)
        actual, err := client.{{ $modelName }}WithSKUExists(mockDB, exampleSKU)

        require.Nil(t, err)
        require.True(t, actual)
        require.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
    t.Run("with no rows found", func(t *testing.T) {
        set{{ $modelName }}WithSKUExistenceQueryExpectation(t, mock, exampleSKU, true, sql.ErrNoRows)
        actual, err := client.{{ $modelName }}WithSKUExists(mockDB, exampleSKU)

        require.Nil(t, err)
        require.False(t, actual)
        require.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
    t.Run("with a database error", func(t *testing.T) {
        set{{ $modelName }}WithSKUExistenceQueryExpectation(t, mock, exampleSKU, true, errors.New("pineapple on pizza"))
        actual, err := client.{{ $modelName }}WithSKUExists(mockDB, exampleSKU)

        require.NotNil(t, err)
        require.False(t, actual)
        require.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}
{{- end }}

{{- if $isProductRoot }}
{{ $existenceWithSKUPrefixQueryVarName := printf "%sWithSKUPrefixExistenceQuery" ( camel $modelName ) -}}
func set{{ $modelName }}WithSKUPrefixExistenceQueryExpectation(t *testing.T, mock sqlmock.Sqlmock, skuPrefix string, shouldExist bool, err error) {
    t.Helper()
    query := formatQueryForSQLMock({{ $existenceWithSKUPrefixQueryVarName }})

	mock.ExpectQuery(query).
		WithArgs(skuPrefix).
		WillReturnRows(sqlmock.NewRows([]string{""}).AddRow(strconv.FormatBool(shouldExist))).
		WillReturnError(err)
}

func Test{{ $modelName }}WithSKUExists(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    require.Nil(t, err)
    defer mockDB.Close()
    exampleSKUPrefix := "example"
    client := NewPostgres()

    t.Run("existing", func(t *testing.T) {
        set{{ $modelName }}WithSKUPrefixExistenceQueryExpectation(t, mock, exampleSKUPrefix, true, nil)
        actual, err := client.{{ $modelName }}WithSKUPrefixExists(mockDB, exampleSKUPrefix)

        require.Nil(t, err)
        require.True(t, actual)
        require.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
    t.Run("with no rows found", func(t *testing.T) {
        set{{ $modelName }}WithSKUPrefixExistenceQueryExpectation(t, mock, exampleSKUPrefix, true, sql.ErrNoRows)
        actual, err := client.{{ $modelName }}WithSKUPrefixExists(mockDB, exampleSKUPrefix)

        require.Nil(t, err)
        require.False(t, actual)
        require.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
    t.Run("with a database error", func(t *testing.T) {
        set{{ $modelName }}WithSKUPrefixExistenceQueryExpectation(t, mock, exampleSKUPrefix, true, errors.New("pineapple on pizza"))
        actual, err := client.{{ $modelName }}WithSKUPrefixExists(mockDB, exampleSKUPrefix)

        require.NotNil(t, err)
        require.False(t, actual)
        require.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}
{{- end }}

{{- if $isLoginAttempt }}
func setExpectationsFor{{ $modelName }}ExhaustionQuery(mock sqlmock.Sqlmock, username string, exhausted bool, shouldError bool) {
	count := 0
	if exhausted {
		count = 666
	}

    var argToReturn interface{} = count
    if shouldError {
        argToReturn = "hello"
    }

	exampleRows := sqlmock.NewRows([]string{""}).AddRow(argToReturn)
	query := formatQueryForSQLMock({{ camel $modelName }}ExhaustionQuery)
	mock.ExpectQuery(query).
		WithArgs(username).
		WillReturnRows(exampleRows)
}

func Test{{ $modelName }}sHaveBeenExhausted(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    require.Nil(t, err)
    defer mockDB.Close()
    client := NewPostgres()
    exampleUsername := "username"

    t.Run("optimal behavior", func(*testing.T){
        expected := false
        setExpectationsFor{{ $modelName }}ExhaustionQuery(mock, exampleUsername, expected, false)
        actual, err := client.{{ $modelName }}sHaveBeenExhausted(mockDB, exampleUsername)

        require.Nil(t, err)
        require.Equal(t, expected, actual)
    })

    t.Run("with db error", func(*testing.T){
        expected := false
        setExpectationsFor{{ $modelName }}ExhaustionQuery(mock, exampleUsername, expected, true)
        actual, err := client.{{ $modelName }}sHaveBeenExhausted(mockDB, exampleUsername)

        require.NotNil(t, err)
        require.Equal(t, expected, actual)
    })
}
{{- end }}

{{ $existenceQueryVarName := printf "%sExistenceQuery" ( camel $modelName ) -}}
func set{{ $modelName }}ExistenceQueryExpectation(t *testing.T, mock sqlmock.Sqlmock, id uint64, shouldExist bool, err error) {
    t.Helper()
    query := formatQueryForSQLMock({{ $existenceQueryVarName }})

	mock.ExpectQuery(query).
		WithArgs(id).
		WillReturnRows(sqlmock.NewRows([]string{""}).AddRow(strconv.FormatBool(shouldExist))).
		WillReturnError(err)
}

func Test{{ $modelName }}Exists(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    require.Nil(t, err)
    defer mockDB.Close()
    exampleID := uint64(1)
    client := NewPostgres()

    t.Run("existing", func(t *testing.T) {
        set{{ $modelName }}ExistenceQueryExpectation(t, mock, exampleID, true, nil)
        actual, err := client.{{ $modelName }}Exists(mockDB, exampleID)

        require.Nil(t, err)
        require.True(t, actual)
        require.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
    t.Run("with no rows found", func(t *testing.T) {
        set{{ $modelName }}ExistenceQueryExpectation(t, mock, exampleID, true, sql.ErrNoRows)
        actual, err := client.{{ $modelName }}Exists(mockDB, exampleID)

        require.Nil(t, err)
        require.False(t, actual)
        require.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
    t.Run("with a database error", func(t *testing.T) {
        set{{ $modelName }}ExistenceQueryExpectation(t, mock, exampleID, true, errors.New("pineapple on pizza"))
        actual, err := client.{{ $modelName }}Exists(mockDB, exampleID)

        require.NotNil(t, err)
        require.False(t, actual)
        require.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}

func set{{ $modelName }}ReadQueryExpectation(t *testing.T, mock sqlmock.Sqlmock, id uint64, toReturn *models.{{ $modelName }}, err error) {
    t.Helper()
    query := formatQueryForSQLMock({{ $readQueryVarName }})

    exampleRows := sqlmock.NewRows([]string{
        {{ range $_, $x := .Table.Columns.DBNames }}{{ printf "\"%s\"" $x }},
        {{ end }}
    }).AddRow(
        {{ range $_, $x := .Table.Columns.DBNames }}toReturn.{{ if or (eq (toLower $x) "sku") (eq (toLower $x) "upc") }}{{ toUpper $x }}{{ else if eq (toLower $x) "sku_prefix" }}SKUPrefix{{ else }}{{ pascal $x }}{{ end }},
        {{ end }}
    )
    mock.ExpectQuery(query).WithArgs(id).WillReturnRows(exampleRows).WillReturnError(err)
}

func TestGet{{ $modelName }}(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    require.Nil(t, err)
    defer mockDB.Close()
    exampleID := uint64(1)
    expected := &models.{{ $modelName }}{ID: exampleID}
    client := NewPostgres()

    t.Run("optimal behavior", func(t *testing.T) {
        set{{ $modelName }}ReadQueryExpectation(t, mock, exampleID, expected, nil)
        actual, err := client.Get{{ $modelName }}(mockDB, exampleID)

        require.Nil(t, err)
        require.Equal(t, expected, actual, "expected {{ toLower $modelName }} did not match actual {{ toLower $modelName }}")
        require.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}

func set{{ $modelName }}ListReadQueryExpectation(t *testing.T, mock sqlmock.Sqlmock, qf *models.QueryFilter, example *models.{{ $modelName }}, rowErr error, err error) {
    exampleRows := sqlmock.NewRows([]string{
        {{ range $_, $x := .Table.Columns.DBNames }}{{ printf "\"%s\"" $x }},
        {{ end }}
    }).AddRow(
        {{ range $_, $x := .Table.Columns.DBNames }}example.{{ if or (eq (toLower $x) "sku") (eq (toLower $x) "upc") }}{{ toUpper $x }}{{ else if eq (toLower $x) "sku_prefix" }}SKUPrefix{{ else }}{{ pascal $x }}{{ end }},
        {{ end }}
    ).AddRow(
        {{ range $_, $x := .Table.Columns.DBNames }}example.{{ if or (eq (toLower $x) "sku") (eq (toLower $x) "upc") }}{{ toUpper $x }}{{ else if eq (toLower $x) "sku_prefix" }}SKUPrefix{{ else }}{{ pascal $x }}{{ end }},
        {{ end }}
    ).AddRow(
        {{ range $_, $x := .Table.Columns.DBNames }}example.{{ if or (eq (toLower $x) "sku") (eq (toLower $x) "upc") }}{{ toUpper $x }}{{ else if eq (toLower $x) "sku_prefix" }}SKUPrefix{{ else }}{{ pascal $x }}{{ end }},
        {{ end }}
    ).RowError(1, rowErr)

    query, _ := build{{ $modelName }}ListRetrievalQuery(qf)

	mock.ExpectQuery(formatQueryForSQLMock(query)).
        WillReturnRows(exampleRows).
		WillReturnError(err)
}

func TestGet{{ $modelName }}List(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    require.Nil(t, err)
    defer mockDB.Close()
    exampleID := uint64(1)
    example := &models.{{ $modelName }}{ID: exampleID}
    client := NewPostgres()
    exampleQF := &models.QueryFilter{
        Limit: 25,
        Page: 1,
    }

    t.Run("optimal behavior", func(t *testing.T) {
        set{{ $modelName }}ListReadQueryExpectation(t, mock, exampleQF, example, nil, nil)
        actual, err := client.Get{{ $modelName }}List(mockDB, exampleQF)

        require.Nil(t, err)
        require.NotEmpty(t, actual, "list retrieval method should not return an empty slice")
        require.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
    t.Run("with error executing query", func(t *testing.T) {
        set{{ $modelName }}ListReadQueryExpectation(t, mock, exampleQF, example, nil, errors.New("pineapple on pizza"))
        actual, err := client.Get{{ $modelName }}List(mockDB, exampleQF)

        require.NotNil(t, err)
        require.Nil(t, actual)
        require.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
    t.Run("with error scanning values", func(t *testing.T) {
        exampleRows := sqlmock.NewRows([]string{"things"}).AddRow("stuff")
        query, _ := build{{ $modelName }}ListRetrievalQuery(exampleQF)
        mock.ExpectQuery(formatQueryForSQLMock(query)).
            WillReturnRows(exampleRows)

        actual, err := client.Get{{ $modelName }}List(mockDB, exampleQF)

        require.NotNil(t, err)
        require.Nil(t, actual)
        require.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
    t.Run("with with row errors", func(t *testing.T) {
        set{{ $modelName }}ListReadQueryExpectation(t, mock, exampleQF, example, errors.New("pineapple on pizza"), nil)
        actual, err := client.Get{{ $modelName }}List(mockDB, exampleQF)

        require.NotNil(t, err)
        require.Nil(t, actual)
        require.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}

func TestBuild{{ $modelName }}CountRetrievalQuery(t *testing.T) {
    t.Parallel()

    exampleQF := &models.QueryFilter{
        Limit: 25,
        Page: 1,
    }
    expected := `SELECT count(id) FROM {{ .Table.Name }} WHERE archived_on IS NULL LIMIT 25`
    actual, _ := build{{ $modelName }}CountRetrievalQuery(exampleQF)

    require.Equal(t, expected, actual, "expected and actual queries should match")
}

func set{{ $modelName }}CountRetrievalQueryExpectation(t *testing.T, mock sqlmock.Sqlmock, qf *models.QueryFilter, count uint64, err error) {
    t.Helper()
    query, args := build{{ $modelName }}CountRetrievalQuery(qf)
    query = formatQueryForSQLMock(query)

    var argsToExpect []driver.Value
	for _, x := range args {
		argsToExpect = append(argsToExpect, x)
	}

    exampleRow := sqlmock.NewRows([]string{"count"}).AddRow(count)
    mock.ExpectQuery(query).WithArgs(argsToExpect...).WillReturnRows(exampleRow).WillReturnError(err)
}

func TestGet{{ $modelName }}Count(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    require.Nil(t, err)
    defer mockDB.Close()
    client := NewPostgres()
    expected := uint64(123)
    exampleQF := &models.QueryFilter{
        Limit: 25,
        Page: 1,
    }

    t.Run("optimal behavior", func(t *testing.T) {
        set{{ $modelName }}CountRetrievalQueryExpectation(t, mock, exampleQF, expected, nil)
        actual, err := client.Get{{ $modelName }}Count(mockDB, exampleQF)

        require.Nil(t, err)
        require.Equal(t, expected, actual, "count retrieval method should return the expected value")
        require.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}

{{ $creationColumns := .Table.Columns.Names.Except (makeSlice "id" "created_on" "archived_on" "updated_on") -}}
func set{{ $modelName }}CreationQueryExpectation(t *testing.T, mock sqlmock.Sqlmock, toCreate *models.{{ $modelName }}, err error) {
    t.Helper()
    query := formatQueryForSQLMock({{ $creationQueryVarName }})
    exampleRows := sqlmock.NewRows([]string{"id", "created_on"{{- if $isProduct }}, "available_on"{{ end }}}).AddRow(uint64(1), generateExampleTimeForTests(t){{- if $isProduct }}, generateExampleTimeForTests(t){{ end }})
    mock.ExpectQuery(query).
        WithArgs(
            {{ $lastCol := dec (len $creationColumns) -}}
            {{ range $x, $col := $creationColumns -}}
            toCreate.{{ if or (eq (toLower $col) "sku") (eq (toLower $col) "upc") }}{{ toUpper $col }}{{ else if eq (toLower $col) "sku_prefix" }}SKUPrefix{{ else }}{{ pascal $col }}{{ end }},
            {{ end }}
        ).
        WillReturnRows(exampleRows).
        WillReturnError(err)
}

func TestCreate{{ $modelName }}(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    require.Nil(t, err)
    defer mockDB.Close()
    expectedID := uint64(1)
    exampleInput := &models.{{ $modelName }}{ID: expectedID}
        client := NewPostgres()

    t.Run("optimal behavior", func(t *testing.T) {
        set{{ $modelName }}CreationQueryExpectation(t, mock, exampleInput, nil)
        expected := generateExampleTimeForTests(t)
        actualID, actualCreationDate,{{- if $isProduct }} actualAvailableOn, {{ end }}err := client.Create{{ $modelName }}(mockDB, exampleInput)

        require.Nil(t, err)
        require.Equal(t, expectedID, actualID, "expected and actual IDs don't match")
        require.Equal(t, expected, actualCreationDate, "expected creation time did not match actual creation time")
        {{ if $isProduct -}}require.Equal(t, expected, actualAvailableOn, "expected availability time did not match actual availability time"){{ end }}
        require.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}

{{ if $isProductVariantBridge }}
func TestBuildMulti{{ $modelName }}CreationQuery(t *testing.T){
    expectedQuery := `
        INSERT INTO product_variant_bridge
            (
                product_id, product_option_value_id
            )
        VALUES
            (
                ($1, $2),
                ($1, $3),
                ($1, $4),
                ($1, $5),
                ($1, $6)
            )
        RETURNING
            id, created_on;
    `
    expectedValues := []interface{}{
        uint64(1),
        uint64(2),
        uint64(3),
        uint64(4),
        uint64(5),
        uint64(6),
    }

    exampleInput := []uint64{2, 3, 4, 5, 6}
    actualQuery, actualValues := buildMulti{{ $modelName }}CreationQuery(1, exampleInput)

    require.Equal(t, expectedQuery, actualQuery)
    require.Equal(t, actualValues, expectedValues)
}

func setMultiple{{ $modelName }}CreationQueryExpectation(t *testing.T, mock sqlmock.Sqlmock, productID uint64, optionValueIDs []uint64, err error) {
    t.Helper()
    query, args := buildMulti{{ $modelName }}CreationQuery(productID, optionValueIDs)
    queryToExpect := formatQueryForSQLMock(query)

    var argsToExpect []driver.Value
	for _, x := range args {
		argsToExpect = append(argsToExpect, x)
	}

    mock.ExpectExec(queryToExpect).
        WithArgs(argsToExpect...).
        WillReturnResult(sqlmock.NewResult(1, 1)).
        WillReturnError(err)
}

func TestCreateMultiple{{ $modelName }}sForProductID(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    require.Nil(t, err)
    defer mockDB.Close()
    client := NewPostgres()

    t.Run("optimal behavior", func(t *testing.T) {
    exampleProductID := uint64(1)
    exampleOptionValueIDs := []uint64{2, 3, 4, 5, 6}
    setMultiple{{ $modelName }}CreationQueryExpectation(t, mock, exampleProductID, exampleOptionValueIDs, nil)
        err := client.CreateMultiple{{ $modelName }}sForProductID(mockDB, exampleProductID, exampleOptionValueIDs)

        require.Nil(t, err)
        require.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}
{{- end }}

{{ $updateColumns := .Table.Columns.Names.Except (makeSlice "id" "created_on" "archived_on") -}}
func set{{ $modelName }}UpdateQueryExpectation(t *testing.T, mock sqlmock.Sqlmock, toUpdate *models.{{ $modelName }}, err error) {
    t.Helper()
    query := formatQueryForSQLMock({{ $updateQueryVarName }})
    exampleRows := sqlmock.NewRows([]string{"updated_on"}).AddRow(generateExampleTimeForTests(t))
    mock.ExpectQuery(query).
        WithArgs(
            {{ $lastCol := dec (len $updateColumns) -}}
            {{ range $x, $col := $updateColumns -}}
            {{ if eq $col "updated_on"}}{{ else }}toUpdate.{{ if or (eq (toLower $col) "sku") (eq (toLower $col) "upc") }}{{ toUpper $col }}{{ else if eq (toLower $col) "sku_prefix" }}SKUPrefix{{ else }}{{ pascal $col }}{{ end }},
            {{ end }}{{ end }}toUpdate.ID,
        ).
        WillReturnRows(exampleRows).
        WillReturnError(err)
}

func TestUpdate{{ $modelName }}ByID(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    require.Nil(t, err)
    defer mockDB.Close()
    exampleInput := &models.{{ $modelName }}{ID: uint64(1)}
    client := NewPostgres()

    t.Run("optimal behavior", func(t *testing.T) {
        set{{ $modelName }}UpdateQueryExpectation(t, mock, exampleInput, nil)
        expected := generateExampleTimeForTests(t)
        actual, err := client.Update{{ $modelName }}(mockDB, exampleInput)

        require.Nil(t, err)
        require.Equal(t, expected, actual, "expected deletion time did not match actual deletion time")
        require.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}


func set{{ $modelName }}DeletionQueryExpectation(t *testing.T, mock sqlmock.Sqlmock, id uint64, err error) {
    t.Helper()
    query := formatQueryForSQLMock({{ $deletionQueryVarName }})
    exampleRows := sqlmock.NewRows([]string{"archived_on"}).AddRow(generateExampleTimeForTests(t))
    mock.ExpectQuery(query).WithArgs(id).WillReturnRows(exampleRows).WillReturnError(err)
}

func TestDelete{{ $modelName }}ByID(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    require.Nil(t, err)
    defer mockDB.Close()
    exampleID := uint64(1)
    client := NewPostgres()

    t.Run("optimal behavior", func(t *testing.T) {
        set{{ $modelName }}DeletionQueryExpectation(t, mock, exampleID, nil)
        expected := generateExampleTimeForTests(t)
        actual, err := client.Delete{{ $modelName }}(mockDB, exampleID)

        require.Nil(t, err)
        require.Equal(t, expected, actual, "expected deletion time did not match actual deletion time")
        require.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })

    t.Run("with transaction", func(t *testing.T) {
        mock.ExpectBegin()
        set{{ $modelName }}DeletionQueryExpectation(t, mock, exampleID, nil)
        expected := generateExampleTimeForTests(t)
        tx, err := mockDB.Begin()
        require.Nil(t, err, "no error should be returned setting up a transaction in the mock DB")
        actual, err := client.Delete{{ $modelName }}(tx, exampleID)

        require.Nil(t, err)
        require.Equal(t, expected, actual, "expected deletion time did not match actual deletion time")
        require.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}

{{ if $isProductVariantBridge }}
{{ $pvbDeletionQueryVarName := printf "%sDeletionQueryByProductID" ( camel $modelName ) -}}

func set{{ $modelName }}DeletionByProductIDQueryExpectation(t *testing.T, mock sqlmock.Sqlmock, id uint64, err error) {
    t.Helper()
    query := formatQueryForSQLMock({{ $pvbDeletionQueryVarName }})
    exampleRows := sqlmock.NewRows([]string{"archived_on"}).AddRow(generateExampleTimeForTests(t))
    mock.ExpectQuery(query).WithArgs(id).WillReturnRows(exampleRows).WillReturnError(err)
}

func TestDelete{{ $modelName }}ByProductID(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    require.Nil(t, err)
    defer mockDB.Close()
    exampleID := uint64(1)
    client := NewPostgres()

    t.Run("optimal behavior", func(t *testing.T) {
        set{{ $modelName }}DeletionByProductIDQueryExpectation(t, mock, exampleID, nil)
        expected := generateExampleTimeForTests(t)
        actual, err := client.Delete{{ $modelName }}ByProductID(mockDB, exampleID)

        require.Nil(t, err)
        require.Equal(t, expected, actual, "expected deletion time did not match actual deletion time")
        require.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })

    t.Run("with transaction", func(t *testing.T) {
        mock.ExpectBegin()
        set{{ $modelName }}DeletionByProductIDQueryExpectation(t, mock, exampleID, nil)
        expected := generateExampleTimeForTests(t)
        tx, err := mockDB.Begin()
        require.Nil(t, err, "no error should be returned setting up a transaction in the mock DB")
        actual, err := client.Delete{{ $modelName }}ByProductID(tx, exampleID)

        require.Nil(t, err)
        require.Equal(t, expected, actual, "expected deletion time did not match actual deletion time")
        require.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}
{{- end }}