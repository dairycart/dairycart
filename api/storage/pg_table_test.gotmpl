package postgres

{{- $modelName := pascal (trimSuffix .Table.Name "s") }}
{{- $isUser := eq $modelName "User" }}
{{- $isProduct := eq $modelName "Product" }}
{{- $isWebhook := eq $modelName "Webhook" }}
{{- $isDiscount := eq $modelName "Discount" }}
{{- $isProductRoot := eq $modelName "ProductRoot" }}
{{- $isLoginAttempt := eq $modelName "LoginAttempt" }}
{{- $isProductImage := eq $modelName "ProductImage" }}
{{- $isProductOption := eq $modelName "ProductOption" }}
{{- $isProductOptionValue := eq $modelName "ProductOptionValue" }}
{{- $isPasswordResetToken := eq $modelName "PasswordResetToken" }}
{{- $isProductVariantBridge := eq $modelName "ProductVariantBridge" }}

import(
    "database/sql"
    "database/sql/driver"
    "errors"
    "strconv"
    "testing"

    // internal dependencies
	"github.com/dairycart/dairymodels/v1"

    // external dependencies
	"github.com/stretchr/testify/assert"
	"gopkg.in/DATA-DOG/go-sqlmock.v1"
)

{{- $shortVarName := toLower (sliceString $modelName 0 1) }}
{{ $readQueryVarName := printf "%sSelectionQuery" ( camel $modelName ) -}}
{{ $creationQueryVarName := printf "%sCreationQuery" ( camel $modelName ) -}}
{{ $updateQueryVarName := printf "%sUpdateQuery" ( camel $modelName ) -}}
{{ $deletionQueryVarName := printf "%sDeletionQuery" ( camel $modelName ) -}}

{{ if $isProduct }}
{{ $bySKUVarName := printf "%sQueryBySKU" ( camel $modelName ) -}}
func set{{ $modelName }}ReadQueryExpectationBySKU(t *testing.T, mock sqlmock.Sqlmock, sku string, toReturn *models.{{ $modelName }}, err error) {
    t.Helper()
    query := formatQueryForSQLMock({{ $bySKUVarName }})
    exampleRows := sqlmock.NewRows([]string{
        {{ range $_, $x := .Table.Columns.DBNames }}{{ printf "\"%s\"" $x }},
        {{ end }}
    }).AddRow(
        {{ range $_, $x := .Table.Columns.DBNames }}{{ if or (eq (toLower $x) "sku") (eq (toLower $x) "upc") }}toReturn.{{ toUpper $x }},{{ else }}toReturn.{{ pascal $x }},{{ end }}
        {{ end }}
    )
    mock.ExpectQuery(query).WithArgs(sku).WillReturnRows(exampleRows).WillReturnError(err)
}

func TestGet{{ $modelName }}BySKU(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    assert.NoError(t, err)
    defer mockDB.Close()
    client := NewPostgres()

    exampleSKU := "hello"
    expected := &models.{{ $modelName }}{SKU: exampleSKU}

    t.Run("optimal behavior", func(t *testing.T) {
        set{{ $modelName }}ReadQueryExpectationBySKU(t, mock, exampleSKU, expected, nil)
        actual, err := client.Get{{ $modelName }}BySKU(mockDB, exampleSKU)

        assert.NoError(t, err)
        assert.Equal(t, expected, actual, "expected {{ toLower $modelName }} did not match actual {{ toLower $modelName }}")
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}
{{- end }}

{{- if or $isProductOption $isProduct }}
{{ $byProductRootIDVarName := printf "%sQueryByProductRootID" ( camel $modelName ) -}}
func set{{ $modelName }}ReadQueryExpectationByProductRootID(t *testing.T, mock sqlmock.Sqlmock, example *models.{{ $modelName }}, rowErr error, err error) {
    exampleRows := sqlmock.NewRows([]string{
        {{ range $_, $x := .Table.Columns.DBNames }}{{ printf "\"%s\"" $x }},
        {{ end }}
    }).AddRow(
        {{ range $_, $x := .Table.Columns.DBNames }}example.{{ if or (eq (toLower $x) "sku") (eq (toLower $x) "upc") }}{{ toUpper $x }}{{ else }}{{ pascal $x }}{{ end }},
        {{ end }}
    ).AddRow(
        {{ range $_, $x := .Table.Columns.DBNames }}example.{{ if or (eq (toLower $x) "sku") (eq (toLower $x) "upc") }}{{ toUpper $x }}{{ else }}{{ pascal $x }}{{ end }},
        {{ end }}
    ).AddRow(
        {{ range $_, $x := .Table.Columns.DBNames }}example.{{ if or (eq (toLower $x) "sku") (eq (toLower $x) "upc") }}{{ toUpper $x }}{{ else }}{{ pascal $x }}{{ end }},
        {{ end }}
    ).RowError(1, rowErr)

	mock.ExpectQuery(formatQueryForSQLMock({{ $byProductRootIDVarName }})).
        WillReturnRows(exampleRows).
		WillReturnError(err)
}

func TestGet{{ $modelName }}sByProductRootID(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    assert.NoError(t, err)
    defer mockDB.Close()
    client := NewPostgres()

    exampleProductRootID := uint64(1)
    example := &models.{{ $modelName }}{ProductRootID: exampleProductRootID}

    t.Run("optimal behavior", func(t *testing.T) {
        set{{ $modelName }}ReadQueryExpectationByProductRootID(t, mock, example, nil, nil)
        actual, err := client.Get{{ $modelName }}sByProductRootID(mockDB, exampleProductRootID)

        assert.NoError(t, err)
        assert.NotEmpty(t, actual, "list retrieval method should not return an empty slice")
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })

	t.Run("with error executing query", func(t *testing.T) {
        set{{ $modelName }}ReadQueryExpectationByProductRootID(t, mock, example, nil, errors.New("pineapple on pizza"))
        actual, err := client.Get{{ $modelName }}sByProductRootID(mockDB, exampleProductRootID)

        assert.NotNil(t, err)
        assert.Nil(t, actual)
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })

	t.Run("with error scanning values", func(t *testing.T) {
        exampleRows := sqlmock.NewRows([]string{"things"}).AddRow("stuff")
        mock.ExpectQuery(formatQueryForSQLMock({{ $byProductRootIDVarName }})).
            WillReturnRows(exampleRows)

        actual, err := client.Get{{ $modelName }}sByProductRootID(mockDB, exampleProductRootID)

        assert.NotNil(t, err)
        assert.Nil(t, actual)
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })

	t.Run("with with row errors", func(t *testing.T) {
        set{{ $modelName }}ReadQueryExpectationByProductRootID(t, mock, example, errors.New("pineapple on pizza"), nil)
        actual, err := client.Get{{ $modelName }}sByProductRootID(mockDB, exampleProductRootID)

        assert.NotNil(t, err)
        assert.Nil(t, actual)
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}
{{- end }}

{{- if $isUser }}
{{- $byUsernameVarName := printf "%sQueryByUsername" ( camel $modelName ) -}}
func set{{ $modelName }}ReadQueryExpectationByUsername(t *testing.T, mock sqlmock.Sqlmock, username string, toReturn *models.{{ $modelName }}, err error) {
    t.Helper()
    query := formatQueryForSQLMock({{ $byUsernameVarName }})
    exampleRows := sqlmock.NewRows([]string{
        {{ range $_, $x := .Table.Columns.DBNames }}{{ printf "\"%s\"" $x }},
        {{ end }}
    }).AddRow(
        {{ range $_, $x := .Table.Columns.DBNames }}toReturn.{{ pascal $x }},
        {{ end }}
    )
    mock.ExpectQuery(query).WithArgs(username).WillReturnRows(exampleRows).WillReturnError(err)
}

func TestGet{{ $modelName }}ByUsername(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    assert.NoError(t, err)
    defer mockDB.Close()
    client := NewPostgres()

    exampleUsername := "username"
    expected := &models.{{ $modelName }}{Username: exampleUsername}

    t.Run("optimal behavior", func(t *testing.T) {
        set{{ $modelName }}ReadQueryExpectationByUsername(t, mock, exampleUsername, expected, nil)
        actual, err := client.Get{{ $modelName }}ByUsername(mockDB, exampleUsername)

        assert.NoError(t, err)
        assert.Equal(t, expected, actual, "expected {{ toLower $modelName }} did not match actual {{ toLower $modelName }}")
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}

{{ $existenceWithUsernameQueryVarName := printf "%sWithUsernameExistenceQuery" ( camel $modelName ) -}}
func set{{ $modelName }}WithUsernameExistenceQueryExpectation(t *testing.T, mock sqlmock.Sqlmock, username string, shouldExist bool, err error) {
    t.Helper()
    query := formatQueryForSQLMock({{ $existenceWithUsernameQueryVarName }})

	mock.ExpectQuery(query).
		WithArgs(username).
		WillReturnRows(sqlmock.NewRows([]string{""}).AddRow(strconv.FormatBool(shouldExist))).
		WillReturnError(err)
}

func Test{{ $modelName }}WithUsernameExists(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    assert.NoError(t, err)
    defer mockDB.Close()
    exampleUsername := "username"
    client := NewPostgres()

    t.Run("existing", func(t *testing.T) {
        set{{ $modelName }}WithUsernameExistenceQueryExpectation(t, mock, exampleUsername, true, nil)
        actual, err := client.{{ $modelName }}WithUsernameExists(mockDB, exampleUsername)

        assert.NoError(t, err)
        assert.True(t, actual)
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })

	t.Run("with no rows found", func(t *testing.T) {
        set{{ $modelName }}WithUsernameExistenceQueryExpectation(t, mock, exampleUsername, true, sql.ErrNoRows)
        actual, err := client.{{ $modelName }}WithUsernameExists(mockDB, exampleUsername)

        assert.NoError(t, err)
        assert.False(t, actual)
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })

	t.Run("with a database error", func(t *testing.T) {
        set{{ $modelName }}WithUsernameExistenceQueryExpectation(t, mock, exampleUsername, true, errors.New("pineapple on pizza"))
        actual, err := client.{{ $modelName }}WithUsernameExists(mockDB, exampleUsername)

        assert.NotNil(t, err)
        assert.False(t, actual)
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}
{{ end }}

{{ if $isDiscount }}
{{ $byCodeVarName := printf "%sQueryByCode" ( camel $modelName ) -}}
func set{{ $modelName }}ReadQueryExpectationByCode(t *testing.T, mock sqlmock.Sqlmock, code string, toReturn *models.{{ $modelName }}, err error) {
    t.Helper()
    query := formatQueryForSQLMock({{ $byCodeVarName }})

    exampleRows := sqlmock.NewRows([]string{
        {{ range $_, $x := .Table.Columns.DBNames }}{{ printf "\"%s\"" $x }},
        {{ end }}
    }).AddRow(
        {{ range $_, $x := .Table.Columns.DBNames }}{{ if or (eq (toLower $x) "sku") (eq (toLower $x) "upc") }}toReturn.{{ toUpper $x }},{{ else }}toReturn.{{ pascal $x }},{{ end }}
        {{ end }}
    )
    mock.ExpectQuery(query).WithArgs(code).WillReturnRows(exampleRows).WillReturnError(err)
}

func TestGet{{ $modelName }}ByCode(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    assert.NoError(t, err)
    defer mockDB.Close()
    client := NewPostgres()

    exampleCode := "welcome"
    expected := &models.{{ $modelName }}{Code: exampleCode}

    t.Run("optimal behavior", func(t *testing.T) {
        set{{ $modelName }}ReadQueryExpectationByCode(t, mock, exampleCode, expected, nil)
        actual, err := client.Get{{ $modelName }}ByCode(mockDB, exampleCode)

        assert.NoError(t, err)
        assert.Equal(t, expected, actual, "expected {{ toLower $modelName }} did not match actual {{ toLower $modelName }}")
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}
{{ end }}

{{- if $isProduct }}
{{ $existenceWithSKUQueryVarName := printf "%sWithSKUExistenceQuery" ( camel $modelName ) -}}
func set{{ $modelName }}WithSKUExistenceQueryExpectation(t *testing.T, mock sqlmock.Sqlmock, sku string, shouldExist bool, err error) {
    t.Helper()
    query := formatQueryForSQLMock({{ $existenceWithSKUQueryVarName }})

	mock.ExpectQuery(query).
		WithArgs(sku).
		WillReturnRows(sqlmock.NewRows([]string{""}).AddRow(strconv.FormatBool(shouldExist))).
		WillReturnError(err)
}

func Test{{ $modelName }}WithSKUExists(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    assert.NoError(t, err)
    defer mockDB.Close()
    exampleSKU := "example"
    client := NewPostgres()

    t.Run("existing", func(t *testing.T) {
        set{{ $modelName }}WithSKUExistenceQueryExpectation(t, mock, exampleSKU, true, nil)
        actual, err := client.{{ $modelName }}WithSKUExists(mockDB, exampleSKU)

        assert.NoError(t, err)
        assert.True(t, actual)
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })

	t.Run("with no rows found", func(t *testing.T) {
        set{{ $modelName }}WithSKUExistenceQueryExpectation(t, mock, exampleSKU, true, sql.ErrNoRows)
        actual, err := client.{{ $modelName }}WithSKUExists(mockDB, exampleSKU)

        assert.NoError(t, err)
        assert.False(t, actual)
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })

	t.Run("with a database error", func(t *testing.T) {
        set{{ $modelName }}WithSKUExistenceQueryExpectation(t, mock, exampleSKU, true, errors.New("pineapple on pizza"))
        actual, err := client.{{ $modelName }}WithSKUExists(mockDB, exampleSKU)

        assert.NotNil(t, err)
        assert.False(t, actual)
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}
{{- end }}


{{- if $isProductOption }}
{{ $existenceByProductRootIDAndNameQueryVarName := printf "%sForNameAndProductIDExistenceQuery" ( camel $modelName ) -}}
func set{{ $modelName }}WithNameProductIDExistenceQueryExpectation(t *testing.T, mock sqlmock.Sqlmock, productRootID uint64, name string, shouldExist bool, err error) {
    t.Helper()
    query := formatQueryForSQLMock({{ $existenceByProductRootIDAndNameQueryVarName }})

	mock.ExpectQuery(query).
		WithArgs(name, productRootID).
		WillReturnRows(sqlmock.NewRows([]string{""}).AddRow(strconv.FormatBool(shouldExist))).
		WillReturnError(err)
}

func Test{{ $modelName }}WithNameExistsForProductRoot(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    assert.NoError(t, err)
    defer mockDB.Close()
    exampleProductRootID := uint64(1)
    exampleName := "example"
    client := NewPostgres()

    t.Run("existing", func(t *testing.T) {
        set{{ $modelName }}WithNameProductIDExistenceQueryExpectation(t, mock, exampleProductRootID, exampleName, true, nil)
        actual, err := client.{{ $modelName }}WithNameExistsForProductRoot(mockDB, exampleName, exampleProductRootID)

        assert.NoError(t, err)
        assert.True(t, actual)
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })

	t.Run("with no rows found", func(t *testing.T) {
        set{{ $modelName }}WithNameProductIDExistenceQueryExpectation(t, mock, exampleProductRootID, exampleName, true, sql.ErrNoRows)
        actual, err := client.{{ $modelName }}WithNameExistsForProductRoot(mockDB, exampleName, exampleProductRootID)

        assert.NoError(t, err)
        assert.False(t, actual)
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })

	t.Run("with a database error", func(t *testing.T) {
        set{{ $modelName }}WithNameProductIDExistenceQueryExpectation(t, mock, exampleProductRootID, exampleName, true, errors.New("pineapple on pizza"))
        actual, err := client.{{ $modelName }}WithNameExistsForProductRoot(mockDB, exampleName, exampleProductRootID)

        assert.NotNil(t, err)
        assert.False(t, actual)
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}
{{- end }}


{{- if $isProductOptionValue }}
{{ $existenceByOptionIDQueryVarName := printf "%sForOptionIDExistenceQuery" ( camel $modelName ) -}}
func set{{ $modelName }}ForOptionIDExistenceQueryExpectation(t *testing.T, mock sqlmock.Sqlmock, optionID uint64, value string, shouldExist bool, err error) {
    t.Helper()
    query := formatQueryForSQLMock({{ $existenceByOptionIDQueryVarName }})

	mock.ExpectQuery(query).
		WithArgs(optionID, value).
		WillReturnRows(sqlmock.NewRows([]string{""}).AddRow(strconv.FormatBool(shouldExist))).
		WillReturnError(err)
}

func Test{{ $modelName }}ForOptionIDExists(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    assert.NoError(t, err)
    defer mockDB.Close()
    exampleOptionID := uint64(1)
    exampleValue := "example"
    client := NewPostgres()

    t.Run("existing", func(t *testing.T) {
        set{{ $modelName }}ForOptionIDExistenceQueryExpectation(t, mock, exampleOptionID, exampleValue, true, nil)
        actual, err := client.{{ $modelName }}ForOptionIDExists(mockDB, exampleOptionID, exampleValue)

        assert.NoError(t, err)
        assert.True(t, actual)
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })

	t.Run("with no rows found", func(t *testing.T) {
        set{{ $modelName }}ForOptionIDExistenceQueryExpectation(t, mock, exampleOptionID, exampleValue, true, sql.ErrNoRows)
        actual, err := client.{{ $modelName }}ForOptionIDExists(mockDB, exampleOptionID, exampleValue)

        assert.NoError(t, err)
        assert.False(t, actual)
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })

	t.Run("with a database error", func(t *testing.T) {
        set{{ $modelName }}ForOptionIDExistenceQueryExpectation(t, mock, exampleOptionID, exampleValue, true, errors.New("pineapple on pizza"))
        actual, err := client.{{ $modelName }}ForOptionIDExists(mockDB, exampleOptionID, exampleValue)

        assert.NotNil(t, err)
        assert.False(t, actual)
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}

{{ $archiveValuesByOptionIDVarName := printf "%sArchiveQueryByOptionID" ( camel $modelName ) -}}
func set{{ $modelName }}DeletionQueryByOptionIDExpectation(t *testing.T, mock sqlmock.Sqlmock, id uint64, err error) {
    t.Helper()
    query := formatQueryForSQLMock({{ $archiveValuesByOptionIDVarName }})
    exampleRows := sqlmock.NewRows([]string{"archived_on"}).AddRow(buildTestTime(t))
    mock.ExpectQuery(query).WithArgs(id).WillReturnRows(exampleRows).WillReturnError(err)
}

func TestArchive{{ $modelName }}sForOption(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    assert.NoError(t, err)
    defer mockDB.Close()
    exampleID := uint64(1)
    client := NewPostgres()

    t.Run("optimal behavior", func(t *testing.T) {
        set{{ $modelName }}DeletionQueryByOptionIDExpectation(t, mock, exampleID, nil)
        expected := buildTestTime(t)
        actual, err := client.Archive{{ $modelName }}sForOption(mockDB, exampleID)

        assert.NoError(t, err)
        assert.Equal(t, expected, actual, "expected deletion time did not match actual deletion time")
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}

{{ $getValuesByOptionIDVarName := printf "%sRetrievalQueryByOptionID" ( camel $modelName ) -}}
func set{{ $modelName }}ForOptionIDReadQueryExpectation(t *testing.T, mock sqlmock.Sqlmock, optionID uint64, example *models.{{ $modelName }}, rowErr error, err error) {
    exampleRows := sqlmock.NewRows([]string{
        {{ range $_, $x := .Table.Columns.DBNames }}{{ printf "\"%s\"" $x }},
        {{ end }}
    }).AddRow(
        {{ range $_, $x := .Table.Columns.DBNames }}example.{{ pascal $x }},
        {{ end }}
    ).AddRow(
        {{ range $_, $x := .Table.Columns.DBNames }}example.{{ pascal $x }},
        {{ end }}
    ).AddRow(
        {{ range $_, $x := .Table.Columns.DBNames }}example.{{ pascal $x }},
        {{ end }}
    ).RowError(1, rowErr)

	mock.ExpectQuery(formatQueryForSQLMock({{ $getValuesByOptionIDVarName }})).
        WithArgs(optionID).
        WillReturnRows(exampleRows).
		WillReturnError(err)
}

func TestGet{{ $modelName }}sForOption(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    assert.NoError(t, err)
    defer mockDB.Close()
    exampleID := uint64(1)
    example := &models.{{ $modelName }}{ID: exampleID}
    client := NewPostgres()

    t.Run("optimal behavior", func(t *testing.T) {
        set{{ $modelName }}ForOptionIDReadQueryExpectation(t, mock, exampleID, example, nil, nil)
        actual, err := client.Get{{ $modelName }}sForOption(mockDB, exampleID)

        assert.NoError(t, err)
        assert.NotEmpty(t, actual, "list retrieval method should not return an empty slice")
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })

	t.Run("with error executing query", func(t *testing.T) {
        set{{ $modelName }}ForOptionIDReadQueryExpectation(t, mock, exampleID, example, nil, errors.New("pineapple on pizza"))
        actual, err := client.Get{{ $modelName }}sForOption(mockDB, exampleID)

        assert.NotNil(t, err)
        assert.Nil(t, actual)
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })

	t.Run("with error scanning values", func(t *testing.T) {
        exampleRows := sqlmock.NewRows([]string{"things"}).AddRow("stuff")
        mock.ExpectQuery(formatQueryForSQLMock({{ $getValuesByOptionIDVarName }})).
            WillReturnRows(exampleRows)
        actual, err := client.Get{{ $modelName }}sForOption(mockDB, exampleID)

        assert.NotNil(t, err)
        assert.Nil(t, actual)
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })

	t.Run("with with row errors", func(t *testing.T) {
        set{{ $modelName }}ForOptionIDReadQueryExpectation(t, mock, exampleID, example, errors.New("pineapple on pizza"), nil)
        actual, err := client.Get{{ $modelName }}sForOption(mockDB, exampleID)

        assert.NotNil(t, err)
        assert.Nil(t, actual)
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}
{{- end }}

{{- if $isProductRoot }}
{{ $existenceWithSKUPrefixQueryVarName := printf "%sWithSKUPrefixExistenceQuery" ( camel $modelName ) -}}
func set{{ $modelName }}WithSKUPrefixExistenceQueryExpectation(t *testing.T, mock sqlmock.Sqlmock, skuPrefix string, shouldExist bool, err error) {
    t.Helper()
    query := formatQueryForSQLMock({{ $existenceWithSKUPrefixQueryVarName }})

	mock.ExpectQuery(query).
		WithArgs(skuPrefix).
		WillReturnRows(sqlmock.NewRows([]string{""}).AddRow(strconv.FormatBool(shouldExist))).
		WillReturnError(err)
}

func Test{{ $modelName }}WithSKUExists(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    assert.NoError(t, err)
    defer mockDB.Close()
    exampleSKUPrefix := "example"
    client := NewPostgres()

    t.Run("existing", func(t *testing.T) {
        set{{ $modelName }}WithSKUPrefixExistenceQueryExpectation(t, mock, exampleSKUPrefix, true, nil)
        actual, err := client.{{ $modelName }}WithSKUPrefixExists(mockDB, exampleSKUPrefix)

        assert.NoError(t, err)
        assert.True(t, actual)
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })

	t.Run("with no rows found", func(t *testing.T) {
        set{{ $modelName }}WithSKUPrefixExistenceQueryExpectation(t, mock, exampleSKUPrefix, true, sql.ErrNoRows)
        actual, err := client.{{ $modelName }}WithSKUPrefixExists(mockDB, exampleSKUPrefix)

        assert.NoError(t, err)
        assert.False(t, actual)
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })

	t.Run("with a database error", func(t *testing.T) {
        set{{ $modelName }}WithSKUPrefixExistenceQueryExpectation(t, mock, exampleSKUPrefix, true, errors.New("pineapple on pizza"))
        actual, err := client.{{ $modelName }}WithSKUPrefixExists(mockDB, exampleSKUPrefix)

        assert.NotNil(t, err)
        assert.False(t, actual)
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}
{{- end }}

{{- if $isLoginAttempt }}
func setExpectationsFor{{ $modelName }}ExhaustionQuery(mock sqlmock.Sqlmock, username string, exhausted bool, shouldError bool) {
	count := 0
	if exhausted {
		count = 666
	}

    var argToReturn interface{} = count
    if shouldError {
        argToReturn = "hello"
    }

	exampleRows := sqlmock.NewRows([]string{""}).AddRow(argToReturn)
	query := formatQueryForSQLMock({{ camel $modelName }}ExhaustionQuery)
	mock.ExpectQuery(query).
		WithArgs(username).
		WillReturnRows(exampleRows)
}

func Test{{ $modelName }}sHaveBeenExhausted(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    assert.NoError(t, err)
    defer mockDB.Close()
    client := NewPostgres()
    exampleUsername := "username"

    t.Run("optimal behavior", func(*testing.T){
        expected := false
        setExpectationsFor{{ $modelName }}ExhaustionQuery(mock, exampleUsername, expected, false)
        actual, err := client.{{ $modelName }}sHaveBeenExhausted(mockDB, exampleUsername)

        assert.NoError(t, err)
        assert.Equal(t, expected, actual)
    })

    t.Run("with db error", func(*testing.T){
        expected := false
        setExpectationsFor{{ $modelName }}ExhaustionQuery(mock, exampleUsername, expected, true)
        actual, err := client.{{ $modelName }}sHaveBeenExhausted(mockDB, exampleUsername)

        assert.NotNil(t, err)
        assert.Equal(t, expected, actual)
    })
}
{{- end }}

{{- if $isPasswordResetToken }}
{{ $pwtExistenceByUserIDQueryVarName := printf "%sExistenceQueryByUserID" ( camel $modelName ) -}}
func set{{ $modelName }}ExistenceQueryByUserIDExpectation(t *testing.T, mock sqlmock.Sqlmock, id uint64, shouldExist bool, err error) {
    t.Helper()
    query := formatQueryForSQLMock({{ $pwtExistenceByUserIDQueryVarName }})

	mock.ExpectQuery(query).
		WithArgs(id).
		WillReturnRows(sqlmock.NewRows([]string{""}).AddRow(strconv.FormatBool(shouldExist))).
		WillReturnError(err)
}

func Test{{ $modelName }}ForUserIDExists(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    assert.NoError(t, err)
    defer mockDB.Close()
    exampleID := uint64(1)
    client := NewPostgres()

    t.Run("existing", func(t *testing.T) {
        set{{ $modelName }}ExistenceQueryByUserIDExpectation(t, mock, exampleID, true, nil)
        actual, err := client.{{ $modelName }}ForUserIDExists(mockDB, exampleID)

        assert.NoError(t, err)
        assert.True(t, actual)
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })

    t.Run("with no rows found", func(t *testing.T) {
        set{{ $modelName }}ExistenceQueryByUserIDExpectation(t, mock, exampleID, true, sql.ErrNoRows)
        actual, err := client.{{ $modelName }}ForUserIDExists(mockDB, exampleID)

        assert.NoError(t, err)
        assert.False(t, actual)
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })

    t.Run("with a database error", func(t *testing.T) {
        set{{ $modelName }}ExistenceQueryByUserIDExpectation(t, mock, exampleID, true, errors.New("pineapple on pizza"))
        actual, err := client.{{ $modelName }}ForUserIDExists(mockDB, exampleID)

        assert.NotNil(t, err)
        assert.False(t, actual)
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}

{{ $pwtExistenceByTokenQueryVarName := printf "%sExistenceQueryByToken" ( camel $modelName ) -}}
func set{{ $modelName }}ExistenceQueryByTokenExpectation(t *testing.T, mock sqlmock.Sqlmock, token string, shouldExist bool, err error) {
    t.Helper()
    query := formatQueryForSQLMock({{ $pwtExistenceByTokenQueryVarName }})

	mock.ExpectQuery(query).
		WithArgs(token).
		WillReturnRows(sqlmock.NewRows([]string{""}).AddRow(strconv.FormatBool(shouldExist))).
		WillReturnError(err)
}

func Test{{ $modelName }}WithTokenExists(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    assert.NoError(t, err)
    defer mockDB.Close()
    exampleToken := "deadbeef"
    client := NewPostgres()

    t.Run("existing", func(t *testing.T) {
        set{{ $modelName }}ExistenceQueryByTokenExpectation(t, mock, exampleToken, true, nil)
        actual, err := client.{{ $modelName }}WithTokenExists(mockDB, exampleToken)

        assert.NoError(t, err)
        assert.True(t, actual)
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })

    t.Run("with no rows found", func(t *testing.T) {
        set{{ $modelName }}ExistenceQueryByTokenExpectation(t, mock, exampleToken, true, sql.ErrNoRows)
        actual, err := client.{{ $modelName }}WithTokenExists(mockDB, exampleToken)

        assert.NoError(t, err)
        assert.False(t, actual)
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })

    t.Run("with a database error", func(t *testing.T) {
        set{{ $modelName }}ExistenceQueryByTokenExpectation(t, mock, exampleToken, true, errors.New("pineapple on pizza"))
        actual, err := client.{{ $modelName }}WithTokenExists(mockDB, exampleToken)

        assert.NotNil(t, err)
        assert.False(t, actual)
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}
{{- end }}

{{- if $isWebhook }}
{{ $byEventTypeVarName := printf "%sQueryByEventType" ( camel $modelName ) -}}
func set{{ $modelName }}ReadQueryExpectationByEventType(t *testing.T, mock sqlmock.Sqlmock, example *models.{{ $modelName }}, rowErr error, err error) {
    exampleRows := sqlmock.NewRows([]string{
        {{ range $_, $x := .Table.Columns.DBNames }}{{ printf "\"%s\"" $x }},
        {{ end }}
    }).AddRow(
        {{ range $_, $x := .Table.Columns.DBNames }}example.{{ pascal $x }},
        {{ end }}
    ).AddRow(
        {{ range $_, $x := .Table.Columns.DBNames }}example.{{ pascal $x }},
        {{ end }}
    ).AddRow(
        {{ range $_, $x := .Table.Columns.DBNames }}example.{{ pascal $x }},
        {{ end }}
    ).RowError(1, rowErr)

	mock.ExpectQuery(formatQueryForSQLMock({{ $byEventTypeVarName }})).
        WillReturnRows(exampleRows).
		WillReturnError(err)
}

func TestGet{{ $modelName }}sByEventType(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    assert.NoError(t, err)
    defer mockDB.Close()
    client := NewPostgres()

    exampleEventType := "product_updated"
    example := &models.{{ $modelName }}{}

    t.Run("optimal behavior", func(t *testing.T) {
        set{{ $modelName }}ReadQueryExpectationByEventType(t, mock, example, nil, nil)
        actual, err := client.Get{{ $modelName }}sByEventType(mockDB, exampleEventType)

        assert.NoError(t, err)
        assert.NotEmpty(t, actual, "list retrieval method should not return an empty slice")
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })

    t.Run("with error executing query", func(t *testing.T) {
        set{{ $modelName }}ReadQueryExpectationByEventType(t, mock, example, nil, errors.New("pineapple on pizza"))
        actual, err := client.Get{{ $modelName }}sByEventType(mockDB, exampleEventType)

        assert.NotNil(t, err)
        assert.Nil(t, actual)
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })

    t.Run("with error scanning values", func(t *testing.T) {
        exampleRows := sqlmock.NewRows([]string{"things"}).AddRow("stuff")
        mock.ExpectQuery(formatQueryForSQLMock({{ $byEventTypeVarName }})).
            WillReturnRows(exampleRows)

        actual, err := client.Get{{ $modelName }}sByEventType(mockDB, exampleEventType)

        assert.NotNil(t, err)
        assert.Nil(t, actual)
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })

    t.Run("with with row errors", func(t *testing.T) {
        set{{ $modelName }}ReadQueryExpectationByEventType(t, mock, example, errors.New("pineapple on pizza"), nil)
        actual, err := client.Get{{ $modelName }}sByEventType(mockDB, exampleEventType)

        assert.NotNil(t, err)
        assert.Nil(t, actual)
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}
{{- end }}

{{- if $isProductImage }}
func setAssign{{ $modelName }}IDToProductQueryExpectation(t *testing.T,mock sqlmock.Sqlmock, imageID uint64, productID uint64, err error) {
    t.Helper()
    query := formatQueryForSQLMock(assign{{ $modelName }}IDToProductQuery)
    exampleRows := sqlmock.NewRows([]string{"updated_on"}).AddRow(buildTestTime(t))
    mock.ExpectQuery(query).WithArgs(imageID, productID).WillReturnRows(exampleRows).WillReturnError(err)
}

func TestSetPrimary{{ $modelName }}ForProduct(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    assert.NoError(t, err)
    defer mockDB.Close()

    example{{ $modelName }} := &models.{{ $modelName }}{ID: uint64(1)}
    exampleProduct := &models.Product{ID: uint64(2)}
    client := NewPostgres()

    t.Run("normal operation", func(*testing.T) {
        setAssign{{ $modelName }}IDToProductQueryExpectation(t, mock, example{{ $modelName }}.ID, exampleProduct.ID, nil)

        expected := buildTestTime(t)
        actual, err := client.SetPrimary{{ $modelName }}ForProduct(mockDB, exampleProduct.ID, example{{ $modelName }}.ID)
        assert.NoError(t, err)
        assert.Equal(t, expected, actual)
    })
}

{{ $imagesByProductIDVarName := printf "%sQueryByProductID" ( camel $modelName ) -}}
func set{{ $modelName }}ByProductIDQueryExpectation(t *testing.T, mock sqlmock.Sqlmock, id uint64, example *models.{{ $modelName }}, rowErr error, err error) {
    t.Helper()

    exampleRows := sqlmock.NewRows([]string{
        {{ range $_, $x := .Table.Columns.DBNames }}{{ printf "\"%s\"" $x }},
        {{ end }}
    }).AddRow(
        {{ range $_, $x := .Table.Columns.DBNames }}example.{{ pascal $x }},
        {{ end }}
    ).AddRow(
        {{ range $_, $x := .Table.Columns.DBNames }}example.{{ pascal $x }},
        {{ end }}
    ).AddRow(
        {{ range $_, $x := .Table.Columns.DBNames }}example.{{ pascal $x }},
        {{ end }}
    ).RowError(1, rowErr)

    query := formatQueryForSQLMock({{ $imagesByProductIDVarName }})
	mock.ExpectQuery(query).
		WithArgs(id).
        WillReturnRows(exampleRows).
		WillReturnError(err)
}

func TestGet{{ $modelName }}sByProductID(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    assert.NoError(t, err)
    defer mockDB.Close()
    exampleID := uint64(1)
    example := &models.{{ $modelName }}{ID: exampleID}
    client := NewPostgres()

    t.Run("optimal behavior", func(t *testing.T) {
        set{{ $modelName }}ByProductIDQueryExpectation(t, mock, exampleID, example, nil, nil)
        actual, err := client.Get{{ $modelName }}sByProductID(mockDB, exampleID)

        assert.NoError(t, err)
        assert.NotEmpty(t, actual, "list retrieval method should not return an empty slice")
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })

    t.Run("with error executing query", func(t *testing.T) {
        set{{ $modelName }}ByProductIDQueryExpectation(t, mock, exampleID, example, nil, errors.New("pineapple on pizza"))
        actual, err := client.Get{{ $modelName }}sByProductID(mockDB, exampleID)

        assert.NotNil(t, err)
        assert.Nil(t, actual)
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })

    t.Run("with error scanning values", func(t *testing.T) {
        exampleRows := sqlmock.NewRows([]string{"things"}).AddRow("stuff")
        query := formatQueryForSQLMock({{ $imagesByProductIDVarName }})
        mock.ExpectQuery(query).
            WillReturnRows(exampleRows)

        actual, err := client.Get{{ $modelName }}sByProductID(mockDB, exampleID)

        assert.NotNil(t, err)
        assert.Nil(t, actual)
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })

    t.Run("with with row errors", func(t *testing.T) {
        set{{ $modelName }}ByProductIDQueryExpectation(t, mock, exampleID, example, errors.New("pineapple on pizza"), nil)
        actual, err := client.Get{{ $modelName }}sByProductID(mockDB, exampleID)

        assert.NotNil(t, err)
        assert.Nil(t, actual)
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}
{{- end }}

{{ $existenceQueryVarName := printf "%sExistenceQuery" ( camel $modelName ) -}}
func set{{ $modelName }}ExistenceQueryExpectation(t *testing.T, mock sqlmock.Sqlmock, id uint64, shouldExist bool, err error) {
    t.Helper()
    query := formatQueryForSQLMock({{ $existenceQueryVarName }})

	mock.ExpectQuery(query).
		WithArgs(id).
		WillReturnRows(sqlmock.NewRows([]string{""}).AddRow(strconv.FormatBool(shouldExist))).
		WillReturnError(err)
}

func Test{{ $modelName }}Exists(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    assert.NoError(t, err)
    defer mockDB.Close()
    exampleID := uint64(1)
    client := NewPostgres()

    t.Run("existing", func(t *testing.T) {
        set{{ $modelName }}ExistenceQueryExpectation(t, mock, exampleID, true, nil)
        actual, err := client.{{ $modelName }}Exists(mockDB, exampleID)

        assert.NoError(t, err)
        assert.True(t, actual)
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })

	t.Run("with no rows found", func(t *testing.T) {
        set{{ $modelName }}ExistenceQueryExpectation(t, mock, exampleID, true, sql.ErrNoRows)
        actual, err := client.{{ $modelName }}Exists(mockDB, exampleID)

        assert.NoError(t, err)
        assert.False(t, actual)
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })

	t.Run("with a database error", func(t *testing.T) {
        set{{ $modelName }}ExistenceQueryExpectation(t, mock, exampleID, true, errors.New("pineapple on pizza"))
        actual, err := client.{{ $modelName }}Exists(mockDB, exampleID)

        assert.NotNil(t, err)
        assert.False(t, actual)
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}

func set{{ $modelName }}ReadQueryExpectation(t *testing.T, mock sqlmock.Sqlmock, id uint64, toReturn *models.{{ $modelName }}, err error) {
    t.Helper()
    query := formatQueryForSQLMock({{ $readQueryVarName }})

    exampleRows := sqlmock.NewRows([]string{
        {{ range $_, $x := .Table.Columns.DBNames }}{{ printf "\"%s\"" $x }},
        {{ end }}
    }).AddRow(
        {{ range $_, $x := .Table.Columns.DBNames }}toReturn.{{ if or (eq (toLower $x) "sku") (eq (toLower $x) "upc") }}{{ toUpper $x }}{{ else if eq (toLower $x) "sku_prefix" }}SKUPrefix{{ else }}{{ pascal $x }}{{ end }},
        {{ end }}
    )
    mock.ExpectQuery(query).WithArgs(id).WillReturnRows(exampleRows).WillReturnError(err)
}

func TestGet{{ $modelName }}(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    assert.NoError(t, err)
    defer mockDB.Close()
    exampleID := uint64(1)
    expected := &models.{{ $modelName }}{ID: exampleID}
    client := NewPostgres()

    t.Run("optimal behavior", func(t *testing.T) {
        set{{ $modelName }}ReadQueryExpectation(t, mock, exampleID, expected, nil)
        actual, err := client.Get{{ $modelName }}(mockDB, exampleID)

        assert.NoError(t, err)
        assert.Equal(t, expected, actual, "expected {{ toLower $modelName }} did not match actual {{ toLower $modelName }}")
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}

func set{{ $modelName }}ListReadQueryExpectation(t *testing.T, mock sqlmock.Sqlmock, qf *models.QueryFilter, example *models.{{ $modelName }}, rowErr error, err error) {
    exampleRows := sqlmock.NewRows([]string{
        {{ range $_, $x := .Table.Columns.DBNames }}{{ printf "\"%s\"" $x }},
        {{ end }}
    }).AddRow(
        {{ range $_, $x := .Table.Columns.DBNames }}example.{{ if or (eq (toLower $x) "sku") (eq (toLower $x) "upc") }}{{ toUpper $x }}{{ else if eq (toLower $x) "sku_prefix" }}SKUPrefix{{ else }}{{ pascal $x }}{{ end }},
        {{ end }}
    ).AddRow(
        {{ range $_, $x := .Table.Columns.DBNames }}example.{{ if or (eq (toLower $x) "sku") (eq (toLower $x) "upc") }}{{ toUpper $x }}{{ else if eq (toLower $x) "sku_prefix" }}SKUPrefix{{ else }}{{ pascal $x }}{{ end }},
        {{ end }}
    ).AddRow(
        {{ range $_, $x := .Table.Columns.DBNames }}example.{{ if or (eq (toLower $x) "sku") (eq (toLower $x) "upc") }}{{ toUpper $x }}{{ else if eq (toLower $x) "sku_prefix" }}SKUPrefix{{ else }}{{ pascal $x }}{{ end }},
        {{ end }}
    ).RowError(1, rowErr)

    query, _ := build{{ $modelName }}ListRetrievalQuery(qf)

	mock.ExpectQuery(formatQueryForSQLMock(query)).
        WillReturnRows(exampleRows).
		WillReturnError(err)
}

func TestGet{{ $modelName }}List(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    assert.NoError(t, err)
    defer mockDB.Close()
    exampleID := uint64(1)
    example := &models.{{ $modelName }}{ID: exampleID}
    client := NewPostgres()
    exampleQF := &models.QueryFilter{
        Limit: 25,
        Page: 1,
    }

    t.Run("optimal behavior", func(t *testing.T) {
        set{{ $modelName }}ListReadQueryExpectation(t, mock, exampleQF, example, nil, nil)
        actual, err := client.Get{{ $modelName }}List(mockDB, exampleQF)

        assert.NoError(t, err)
        assert.NotEmpty(t, actual, "list retrieval method should not return an empty slice")
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })

    t.Run("with error executing query", func(t *testing.T) {
        set{{ $modelName }}ListReadQueryExpectation(t, mock, exampleQF, example, nil, errors.New("pineapple on pizza"))
        actual, err := client.Get{{ $modelName }}List(mockDB, exampleQF)

        assert.NotNil(t, err)
        assert.Nil(t, actual)
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })

    t.Run("with error scanning values", func(t *testing.T) {
        exampleRows := sqlmock.NewRows([]string{"things"}).AddRow("stuff")
        query, _ := build{{ $modelName }}ListRetrievalQuery(exampleQF)
        mock.ExpectQuery(formatQueryForSQLMock(query)).
            WillReturnRows(exampleRows)

        actual, err := client.Get{{ $modelName }}List(mockDB, exampleQF)

        assert.NotNil(t, err)
        assert.Nil(t, actual)
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })

    t.Run("with with row errors", func(t *testing.T) {
        set{{ $modelName }}ListReadQueryExpectation(t, mock, exampleQF, example, errors.New("pineapple on pizza"), nil)
        actual, err := client.Get{{ $modelName }}List(mockDB, exampleQF)

        assert.NotNil(t, err)
        assert.Nil(t, actual)
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}

func TestBuild{{ $modelName }}CountRetrievalQuery(t *testing.T) {
    t.Parallel()

    exampleQF := &models.QueryFilter{
        Limit: 25,
        Page: 1,
    }
    expected := `SELECT count(id) FROM {{ .Table.Name }} WHERE archived_on IS NULL LIMIT 25`
    actual, _ := build{{ $modelName }}CountRetrievalQuery(exampleQF)

    assert.Equal(t, expected, actual, "expected and actual queries should match")
}

func set{{ $modelName }}CountRetrievalQueryExpectation(t *testing.T, mock sqlmock.Sqlmock, qf *models.QueryFilter, count uint64, err error) {
    t.Helper()
    query, args := build{{ $modelName }}CountRetrievalQuery(qf)
    query = formatQueryForSQLMock(query)

    var argsToExpect []driver.Value
	for _, x := range args {
		argsToExpect = append(argsToExpect, x)
	}

    exampleRow := sqlmock.NewRows([]string{"count"}).AddRow(count)
    mock.ExpectQuery(query).WithArgs(argsToExpect...).WillReturnRows(exampleRow).WillReturnError(err)
}

func TestGet{{ $modelName }}Count(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    assert.NoError(t, err)
    defer mockDB.Close()
    client := NewPostgres()
    expected := uint64(123)
    exampleQF := &models.QueryFilter{
        Limit: 25,
        Page: 1,
    }

    t.Run("optimal behavior", func(t *testing.T) {
        set{{ $modelName }}CountRetrievalQueryExpectation(t, mock, exampleQF, expected, nil)
        actual, err := client.Get{{ $modelName }}Count(mockDB, exampleQF)

        assert.NoError(t, err)
        assert.Equal(t, expected, actual, "count retrieval method should return the expected value")
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}

{{ $creationColumns := .Table.Columns.Names.Except (makeSlice "id" "created_on" "archived_on" "updated_on") -}}
func set{{ $modelName }}CreationQueryExpectation(t *testing.T, mock sqlmock.Sqlmock, toCreate *models.{{ $modelName }}, err error) {
    t.Helper()
    query := formatQueryForSQLMock({{ $creationQueryVarName }})
    tt := buildTestTime(t)
    exampleRows := sqlmock.NewRows([]string{"id", "created_on"{{- if $isProduct }}, "available_on"{{ end }}}).AddRow(uint64(1), tt{{- if $isProduct }}, tt{{ end }})
    mock.ExpectQuery(query).
        WithArgs(
            {{ $lastCol := dec (len $creationColumns) -}}
            {{ range $x, $col := $creationColumns -}}
            toCreate.{{ if or (eq (toLower $col) "sku") (eq (toLower $col) "upc") }}{{ toUpper $col }}{{ else if eq (toLower $col) "sku_prefix" }}SKUPrefix{{ else }}{{ pascal $col }}{{ end }},
            {{ end }}
        ).
        WillReturnRows(exampleRows).
        WillReturnError(err)
}

func TestCreate{{ $modelName }}(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    assert.NoError(t, err)
    defer mockDB.Close()
    expectedID := uint64(1)
    exampleInput := &models.{{ $modelName }}{ID: expectedID}
    client := NewPostgres()

    t.Run("optimal behavior", func(t *testing.T) {
        set{{ $modelName }}CreationQueryExpectation(t, mock, exampleInput, nil)
        expectedCreatedOn := buildTestTime(t)
        {{ if $isProduct -}}expectedAvailableOn := buildTestTime(t){{ end }}
        actualID, actualCreatedOn, {{- if $isProduct }} actualAvailableOn, {{ end }} err := client.Create{{ $modelName }}(mockDB, exampleInput)

        assert.NoError(t, err)
        assert.Equal(t, expectedID, actualID, "expected and actual IDs don't match")
        assert.Equal(t, expectedCreatedOn, actualCreatedOn, "expected creation time did not match actual creation time")
        {{ if $isProduct -}}assert.Equal(t, expectedAvailableOn, actualAvailableOn, "expected availability time did not match actual availability time"){{ end }}
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}

{{ if $isProductVariantBridge }}
func TestBuildMulti{{ $modelName }}CreationQuery(t *testing.T){
    t.Run("single {{ toLower $modelName }}", func(*testing.T) {
        expectedQuery := `
        INSERT INTO product_variant_bridge
            (
                product_id, product_option_value_id
            )
        VALUES
            (
                $1, $2
            )
        RETURNING
            id, created_on;
    `
        expectedValues := []interface{}{
            uint64(1),
            uint64(2),
        }

        exampleInput := []uint64{2}
        actualQuery, actualValues := buildMulti{{ $modelName }}CreationQuery(1, exampleInput)

        assert.Equal(t, expectedQuery, actualQuery)
        assert.Equal(t, actualValues, expectedValues)
    })

    t.Run("multiple {{ toLower $modelName }}", func(*testing.T) {
        expectedQuery := `
        INSERT INTO product_variant_bridge
            (
                product_id, product_option_value_id
            )
        VALUES
            (
                ($1, $2),
                ($1, $3),
                ($1, $4),
                ($1, $5),
                ($1, $6)
            )
        RETURNING
            id, created_on;
    `
        expectedValues := []interface{}{
            uint64(1),
            uint64(2),
            uint64(3),
            uint64(4),
            uint64(5),
            uint64(6),
        }

        exampleInput := []uint64{2, 3, 4, 5, 6}
        actualQuery, actualValues := buildMulti{{ $modelName }}CreationQuery(1, exampleInput)

        assert.Equal(t, expectedQuery, actualQuery)
        assert.Equal(t, actualValues, expectedValues)
    })
}

func setMultiple{{ $modelName }}CreationQueryExpectation(t *testing.T, mock sqlmock.Sqlmock, productID uint64, optionValueIDs []uint64, err error) {
    t.Helper()
    query, args := buildMulti{{ $modelName }}CreationQuery(productID, optionValueIDs)
    queryToExpect := formatQueryForSQLMock(query)

    var argsToExpect []driver.Value
	for _, x := range args {
		argsToExpect = append(argsToExpect, x)
	}

    mock.ExpectExec(queryToExpect).
        WithArgs(argsToExpect...).
        WillReturnResult(sqlmock.NewResult(1, 1)).
        WillReturnError(err)
}

func TestCreateMultiple{{ $modelName }}sForProductID(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    assert.NoError(t, err)
    defer mockDB.Close()
    client := NewPostgres()

    t.Run("optimal behavior", func(t *testing.T) {
    exampleProductID := uint64(1)
    exampleOptionValueIDs := []uint64{2, 3, 4, 5, 6}
    setMultiple{{ $modelName }}CreationQueryExpectation(t, mock, exampleProductID, exampleOptionValueIDs, nil)
        err := client.CreateMultiple{{ $modelName }}sForProductID(mockDB, exampleProductID, exampleOptionValueIDs)

        assert.NoError(t, err)
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}
{{- end }}

{{ $updateColumns := .Table.Columns.Names.Except (makeSlice "id" "created_on" "archived_on") -}}
func set{{ $modelName }}UpdateQueryExpectation(t *testing.T, mock sqlmock.Sqlmock, toUpdate *models.{{ $modelName }}, err error) {
    t.Helper()
    query := formatQueryForSQLMock({{ $updateQueryVarName }})
    exampleRows := sqlmock.NewRows([]string{"updated_on"}).AddRow(buildTestTime(t))
    mock.ExpectQuery(query).
        WithArgs(
            {{ $lastCol := dec (len $updateColumns) -}}
            {{ range $x, $col := $updateColumns -}}
            {{ if eq $col "updated_on"}}{{ else }}toUpdate.{{ if or (eq (toLower $col) "sku") (eq (toLower $col) "upc") }}{{ toUpper $col }}{{ else if eq (toLower $col) "sku_prefix" }}SKUPrefix{{ else }}{{ pascal $col }}{{ end }},
            {{ end }}{{ end }}toUpdate.ID,
        ).
        WillReturnRows(exampleRows).
        WillReturnError(err)
}

func TestUpdate{{ $modelName }}ByID(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    assert.NoError(t, err)
    defer mockDB.Close()
    exampleInput := &models.{{ $modelName }}{ID: uint64(1)}
    client := NewPostgres()

    t.Run("optimal behavior", func(t *testing.T) {
        set{{ $modelName }}UpdateQueryExpectation(t, mock, exampleInput, nil)
        expected := buildTestTime(t)
        actual, err := client.Update{{ $modelName }}(mockDB, exampleInput)

        assert.NoError(t, err)
        assert.Equal(t, expected, actual, "expected deletion time did not match actual deletion time")
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}

func set{{ $modelName }}DeletionQueryExpectation(t *testing.T, mock sqlmock.Sqlmock, id uint64, err error) {
    t.Helper()
    query := formatQueryForSQLMock({{ $deletionQueryVarName }})
    exampleRows := sqlmock.NewRows([]string{"archived_on"}).AddRow(buildTestTime(t))
    mock.ExpectQuery(query).WithArgs(id).WillReturnRows(exampleRows).WillReturnError(err)
}

func TestDelete{{ $modelName }}ByID(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    assert.NoError(t, err)
    defer mockDB.Close()
    exampleID := uint64(1)
    client := NewPostgres()

    t.Run("optimal behavior", func(t *testing.T) {
        set{{ $modelName }}DeletionQueryExpectation(t, mock, exampleID, nil)
        expected := buildTestTime(t)
        actual, err := client.Delete{{ $modelName }}(mockDB, exampleID)

        assert.NoError(t, err)
        assert.Equal(t, expected, actual, "expected deletion time did not match actual deletion time")
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })

    t.Run("with transaction", func(t *testing.T) {
        mock.ExpectBegin()
        set{{ $modelName }}DeletionQueryExpectation(t, mock, exampleID, nil)
        expected := buildTestTime(t)
        tx, err := mockDB.Begin()
        assert.NoError(t, err, "no error should be returned setting up a transaction in the mock DB")
        actual, err := client.Delete{{ $modelName }}(tx, exampleID)

        assert.NoError(t, err)
        assert.Equal(t, expected, actual, "expected deletion time did not match actual deletion time")
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}

{{/*  these blocks of code are identical now, but may not be in the future, so I'm separating them for good measure  */}}

{{- if $isProductVariantBridge }}
{{ $withRootDeletionQueryVarName := printf "%sWithProductRootIDDeletionQuery" ( camel $modelName ) -}}
func set{{ $modelName }}WithProductRootIDDeletionQueryExpectation(t *testing.T, mock sqlmock.Sqlmock, id uint64, err error) {
    t.Helper()
    query := formatQueryForSQLMock({{ $withRootDeletionQueryVarName }})
    exampleRows := sqlmock.NewRows([]string{"archived_on"}).AddRow(buildTestTime(t))
    mock.ExpectQuery(query).WithArgs(id).WillReturnRows(exampleRows).WillReturnError(err)
}

func TestArchive{{ $modelName }}sWithProductRootID(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    assert.NoError(t, err)
    defer mockDB.Close()
    exampleID := uint64(1)
    client := NewPostgres()

    t.Run("optimal behavior", func(t *testing.T) {
        set{{ $modelName }}WithProductRootIDDeletionQueryExpectation(t, mock, exampleID, nil)
        expected := buildTestTime(t)
        actual, err := client.Archive{{ $modelName }}sWithProductRootID(mockDB, exampleID)

        assert.NoError(t, err)
        assert.Equal(t, expected, actual, "expected deletion time did not match actual deletion time")
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })

    t.Run("with transaction", func(t *testing.T) {
        mock.ExpectBegin()
        set{{ $modelName }}WithProductRootIDDeletionQueryExpectation(t, mock, exampleID, nil)
        expected := buildTestTime(t)
        tx, err := mockDB.Begin()
        assert.NoError(t, err, "no error should be returned setting up a transaction in the mock DB")
        actual, err := client.Archive{{ $modelName }}sWithProductRootID(tx, exampleID)

        assert.NoError(t, err)
        assert.Equal(t, expected, actual, "expected deletion time did not match actual deletion time")
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}
{{- end }}

{{- if $isProductOptionValue }}
{{ $withRootDeletionQueryVarName := printf "%sWithProductRootIDDeletionQuery" ( camel $modelName ) -}}
func set{{ $modelName }}WithProductRootIDDeletionQueryExpectation(t *testing.T, mock sqlmock.Sqlmock, id uint64, err error) {
    t.Helper()
    query := formatQueryForSQLMock({{ $withRootDeletionQueryVarName }})
    exampleRows := sqlmock.NewRows([]string{"archived_on"}).AddRow(buildTestTime(t))
    mock.ExpectQuery(query).WithArgs(id).WillReturnRows(exampleRows).WillReturnError(err)
}

func TestArchive{{ $modelName }}sWithProductRootID(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    assert.NoError(t, err)
    defer mockDB.Close()
    exampleID := uint64(1)
    client := NewPostgres()

    t.Run("optimal behavior", func(t *testing.T) {
        set{{ $modelName }}WithProductRootIDDeletionQueryExpectation(t, mock, exampleID, nil)
        expected := buildTestTime(t)
        actual, err := client.Archive{{ $modelName }}sWithProductRootID(mockDB, exampleID)

        assert.NoError(t, err)
        assert.Equal(t, expected, actual, "expected deletion time did not match actual deletion time")
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })

    t.Run("with transaction", func(t *testing.T) {
        mock.ExpectBegin()
        set{{ $modelName }}WithProductRootIDDeletionQueryExpectation(t, mock, exampleID, nil)
        expected := buildTestTime(t)
        tx, err := mockDB.Begin()
        assert.NoError(t, err, "no error should be returned setting up a transaction in the mock DB")
        actual, err := client.Archive{{ $modelName }}sWithProductRootID(tx, exampleID)

        assert.NoError(t, err)
        assert.Equal(t, expected, actual, "expected deletion time did not match actual deletion time")
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}
{{- end }}

{{- if $isProductOption }}
{{ $withRootDeletionQueryVarName := printf "%sWithProductRootIDDeletionQuery" ( camel $modelName ) -}}
func set{{ $modelName }}WithProductRootIDDeletionQueryExpectation(t *testing.T, mock sqlmock.Sqlmock, id uint64, err error) {
    t.Helper()
    query := formatQueryForSQLMock({{ $withRootDeletionQueryVarName }})
    exampleRows := sqlmock.NewRows([]string{"archived_on"}).AddRow(buildTestTime(t))
    mock.ExpectQuery(query).WithArgs(id).WillReturnRows(exampleRows).WillReturnError(err)
}

func TestArchive{{ $modelName }}sWithProductRootID(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    assert.NoError(t, err)
    defer mockDB.Close()
    exampleID := uint64(1)
    client := NewPostgres()

    t.Run("optimal behavior", func(t *testing.T) {
        set{{ $modelName }}WithProductRootIDDeletionQueryExpectation(t, mock, exampleID, nil)
        expected := buildTestTime(t)
        actual, err := client.Archive{{ $modelName }}sWithProductRootID(mockDB, exampleID)

        assert.NoError(t, err)
        assert.Equal(t, expected, actual, "expected deletion time did not match actual deletion time")
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })

    t.Run("with transaction", func(t *testing.T) {
        mock.ExpectBegin()
        set{{ $modelName }}WithProductRootIDDeletionQueryExpectation(t, mock, exampleID, nil)
        expected := buildTestTime(t)
        tx, err := mockDB.Begin()
        assert.NoError(t, err, "no error should be returned setting up a transaction in the mock DB")
        actual, err := client.Archive{{ $modelName }}sWithProductRootID(tx, exampleID)

        assert.NoError(t, err)
        assert.Equal(t, expected, actual, "expected deletion time did not match actual deletion time")
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}
{{- end }}

{{- if $isProduct }}
{{ $withRootDeletionQueryVarName := printf "%sWithProductRootIDDeletionQuery" ( camel $modelName ) -}}
func set{{ $modelName }}WithProductRootIDDeletionQueryExpectation(t *testing.T, mock sqlmock.Sqlmock, id uint64, err error) {
    t.Helper()
    query := formatQueryForSQLMock({{ $withRootDeletionQueryVarName }})
    exampleRows := sqlmock.NewRows([]string{"archived_on"}).AddRow(buildTestTime(t))
    mock.ExpectQuery(query).WithArgs(id).WillReturnRows(exampleRows).WillReturnError(err)
}

func TestArchive{{ $modelName }}sWithProductRootID(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    assert.NoError(t, err)
    defer mockDB.Close()
    exampleID := uint64(1)
    client := NewPostgres()

    t.Run("optimal behavior", func(t *testing.T) {
        set{{ $modelName }}WithProductRootIDDeletionQueryExpectation(t, mock, exampleID, nil)
        expected := buildTestTime(t)
        actual, err := client.Archive{{ $modelName }}sWithProductRootID(mockDB, exampleID)

        assert.NoError(t, err)
        assert.Equal(t, expected, actual, "expected deletion time did not match actual deletion time")
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })

    t.Run("with transaction", func(t *testing.T) {
        mock.ExpectBegin()
        set{{ $modelName }}WithProductRootIDDeletionQueryExpectation(t, mock, exampleID, nil)
        expected := buildTestTime(t)
        tx, err := mockDB.Begin()
        assert.NoError(t, err, "no error should be returned setting up a transaction in the mock DB")
        actual, err := client.Archive{{ $modelName }}sWithProductRootID(tx, exampleID)

        assert.NoError(t, err)
        assert.Equal(t, expected, actual, "expected deletion time did not match actual deletion time")
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}
{{- end }}

{{ if $isProductVariantBridge }}
{{ $pvbDeletionQueryVarName := printf "%sDeletionQueryByProductID" ( camel $modelName ) -}}

func set{{ $modelName }}DeletionByProductIDQueryExpectation(t *testing.T, mock sqlmock.Sqlmock, id uint64, err error) {
    t.Helper()
    query := formatQueryForSQLMock({{ $pvbDeletionQueryVarName }})
    exampleRows := sqlmock.NewRows([]string{"archived_on"}).AddRow(buildTestTime(t))
    mock.ExpectQuery(query).WithArgs(id).WillReturnRows(exampleRows).WillReturnError(err)
}

func TestDelete{{ $modelName }}ByProductID(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    assert.NoError(t, err)
    defer mockDB.Close()
    exampleID := uint64(1)
    client := NewPostgres()

    t.Run("optimal behavior", func(t *testing.T) {
        set{{ $modelName }}DeletionByProductIDQueryExpectation(t, mock, exampleID, nil)
        expected := buildTestTime(t)
        actual, err := client.Delete{{ $modelName }}ByProductID(mockDB, exampleID)

        assert.NoError(t, err)
        assert.Equal(t, expected, actual, "expected deletion time did not match actual deletion time")
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })

    t.Run("with transaction", func(t *testing.T) {
        mock.ExpectBegin()
        set{{ $modelName }}DeletionByProductIDQueryExpectation(t, mock, exampleID, nil)
        expected := buildTestTime(t)
        tx, err := mockDB.Begin()
        assert.NoError(t, err, "no error should be returned setting up a transaction in the mock DB")
        actual, err := client.Delete{{ $modelName }}ByProductID(tx, exampleID)

        assert.NoError(t, err)
        assert.Equal(t, expected, actual, "expected deletion time did not match actual deletion time")
        assert.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}
{{- end }}