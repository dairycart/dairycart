package postgres

import(
    "database/sql"
    "errors"
    "strconv"
    "testing"

    // internal dependencies
	"github.com/dairycart/dairycart/api/storage/models"

    // external dependencies
	"github.com/stretchr/testify/require"
	"gopkg.in/DATA-DOG/go-sqlmock.v1"
)

{{- $modelName := pascal (trimSuffix .Table.Name "s")}}
{{- $shortVarName := toLower (sliceString $modelName 0 1) }}

{{- $isProduct := eq $modelName "Product" }}
{{- $isDiscount := eq $modelName "Discount" }}
{{- $isProductVariantBridge := eq $modelName "ProductVariantBridge" }}

{{ $readQueryVarName := printf "%sSelectionQuery" ( camel $modelName ) -}}
{{ $creationQueryVarName := printf "%sCreationQuery" ( toLower $modelName ) -}}
{{ $updateQueryVarName := printf "%sUpdateQuery" ( camel $modelName ) -}}
{{ $deletionQueryVarName := printf "%sDeletionQuery" ( camel $modelName ) -}}

{{ if $isProduct }}
{{ $bySKUVarName := printf "%sQueryBySKU" ( camel $modelName ) -}}
func set{{ $modelName }}ReadQueryExpectationBySKU(t *testing.T, mock sqlmock.Sqlmock, sku string, toReturn *models.{{ $modelName }}, err error) {
    t.Helper()
    query := formatQueryForSQLMock({{ $bySKUVarName }})

    exampleRows := sqlmock.NewRows([]string{
        {{ range $_, $x := .Table.Columns.DBNames }}{{ printf "\"%s\"" $x }},
        {{ end }}
    }).AddRow(
        {{ range $_, $x := .Table.Columns.DBNames }}{{ if or (eq (toLower $x) "sku") (eq (toLower $x) "upc") }}toReturn.{{ toUpper $x }},{{ else }}toReturn.{{ pascal $x }},{{ end }}
        {{ end }}
    )
    mock.ExpectQuery(query).WithArgs(sku).WillReturnRows(exampleRows).WillReturnError(err)
}

func TestGet{{ $modelName }}BySKU(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    require.Nil(t, err)
    defer mockDB.Close()
    client := NewPostgres()

    exampleSKU := "hello"
    expected := &models.{{ $modelName }}{SKU: exampleSKU}

    t.Run("optimal behavior", func(t *testing.T) {
        set{{ $modelName }}ReadQueryExpectationBySKU(t, mock, exampleSKU, expected, nil)
        actual, err := client.Get{{ $modelName }}BySKU(mockDB, exampleSKU)

        require.Nil(t, err)
        require.Equal(t, expected, actual, "expected {{ toLower $modelName }} did not match actual {{ toLower $modelName }}")
        require.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}
{{ end }}

{{ if $isDiscount }}
{{ $byCodeVarName := printf "%sQueryByCode" ( camel $modelName ) -}}
func set{{ $modelName }}ReadQueryExpectationByCode(t *testing.T, mock sqlmock.Sqlmock, code string, toReturn *models.{{ $modelName }}, err error) {
    t.Helper()
    query := formatQueryForSQLMock({{ $byCodeVarName }})

    exampleRows := sqlmock.NewRows([]string{
        {{ range $_, $x := .Table.Columns.DBNames }}{{ printf "\"%s\"" $x }},
        {{ end }}
    }).AddRow(
        {{ range $_, $x := .Table.Columns.DBNames }}{{ if or (eq (toLower $x) "sku") (eq (toLower $x) "upc") }}toReturn.{{ toUpper $x }},{{ else }}toReturn.{{ pascal $x }},{{ end }}
        {{ end }}
    )
    mock.ExpectQuery(query).WithArgs(code).WillReturnRows(exampleRows).WillReturnError(err)
}

func TestGet{{ $modelName }}ByCode(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    require.Nil(t, err)
    defer mockDB.Close()
    client := NewPostgres()

    exampleCode := "welcome"
    expected := &models.{{ $modelName }}{Code: exampleCode}

    t.Run("optimal behavior", func(t *testing.T) {
        set{{ $modelName }}ReadQueryExpectationByCode(t, mock, exampleCode, expected, nil)
        actual, err := client.Get{{ $modelName }}ByCode(mockDB, exampleCode)

        require.Nil(t, err)
        require.Equal(t, expected, actual, "expected {{ toLower $modelName }} did not match actual {{ toLower $modelName }}")
        require.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}
{{ end }}

{{- if $isProduct }}

{{ $existenceWithSKUQueryVarName := printf "%sWithSKUExistenceQuery" ( camel $modelName ) -}}
func set{{ $modelName }}WithSKUExistenceQueryExpectation(t *testing.T, mock sqlmock.Sqlmock, sku string, shouldExist bool, err error) {
    t.Helper()
    query := formatQueryForSQLMock({{ $existenceWithSKUQueryVarName }})

	mock.ExpectQuery(query).
		WithArgs(sku).
		WillReturnRows(sqlmock.NewRows([]string{""}).AddRow(strconv.FormatBool(shouldExist))).
		WillReturnError(err)
}

func Test{{ $modelName }}WithSKUExists(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    require.Nil(t, err)
    defer mockDB.Close()
    exampleSKU := "example"
    client := NewPostgres()

    t.Run("existing", func(t *testing.T) {
        set{{ $modelName }}WithSKUExistenceQueryExpectation(t, mock, exampleSKU, true, nil)
        actual, err := client.{{ $modelName }}WithSKUExists(mockDB, exampleSKU)

        require.Nil(t, err)
        require.True(t, actual)
        require.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
    t.Run("with no rows found", func(t *testing.T) {
        set{{ $modelName }}WithSKUExistenceQueryExpectation(t, mock, exampleSKU, true, sql.ErrNoRows)
        actual, err := client.{{ $modelName }}WithSKUExists(mockDB, exampleSKU)

        require.Nil(t, err)
        require.False(t, actual)
        require.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
    t.Run("with a database error", func(t *testing.T) {
        set{{ $modelName }}WithSKUExistenceQueryExpectation(t, mock, exampleSKU, true, errors.New("pineapple on pizza"))
        actual, err := client.{{ $modelName }}WithSKUExists(mockDB, exampleSKU)

        require.NotNil(t, err)
        require.False(t, actual)
        require.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}
{{- end }}

{{ $existenceQueryVarName := printf "%sExistenceQuery" ( camel $modelName ) -}}
func set{{ $modelName }}ExistenceQueryExpectation(t *testing.T, mock sqlmock.Sqlmock, id uint64, shouldExist bool, err error) {
    t.Helper()
    query := formatQueryForSQLMock({{ $existenceQueryVarName }})

	mock.ExpectQuery(query).
		WithArgs(id).
		WillReturnRows(sqlmock.NewRows([]string{""}).AddRow(strconv.FormatBool(shouldExist))).
		WillReturnError(err)
}

func Test{{ $modelName }}Exists(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    require.Nil(t, err)
    defer mockDB.Close()
    exampleID := uint64(1)
    client := NewPostgres()

    t.Run("existing", func(t *testing.T) {
        set{{ $modelName }}ExistenceQueryExpectation(t, mock, exampleID, true, nil)
        actual, err := client.{{ $modelName }}Exists(mockDB, exampleID)

        require.Nil(t, err)
        require.True(t, actual)
        require.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
    t.Run("with no rows found", func(t *testing.T) {
        set{{ $modelName }}ExistenceQueryExpectation(t, mock, exampleID, true, sql.ErrNoRows)
        actual, err := client.{{ $modelName }}Exists(mockDB, exampleID)

        require.Nil(t, err)
        require.False(t, actual)
        require.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
    t.Run("with a database error", func(t *testing.T) {
        set{{ $modelName }}ExistenceQueryExpectation(t, mock, exampleID, true, errors.New("pineapple on pizza"))
        actual, err := client.{{ $modelName }}Exists(mockDB, exampleID)

        require.NotNil(t, err)
        require.False(t, actual)
        require.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}

func set{{ $modelName }}ReadQueryExpectation(t *testing.T, mock sqlmock.Sqlmock, id uint64, toReturn *models.{{ $modelName }}, err error) {
    t.Helper()
    query := formatQueryForSQLMock({{ $readQueryVarName }})

    exampleRows := sqlmock.NewRows([]string{
        {{ range $_, $x := .Table.Columns.DBNames }}{{ printf "\"%s\"" $x }},
        {{ end }}
    }).AddRow(
        {{ range $_, $x := .Table.Columns.DBNames }}{{ if or (eq (toLower $x) "sku") (eq (toLower $x) "upc") }}toReturn.{{ toUpper $x }},{{ else }}toReturn.{{ pascal $x }},{{ end }}
        {{ end }}
    )
    mock.ExpectQuery(query).WithArgs(id).WillReturnRows(exampleRows).WillReturnError(err)
}

func TestGet{{ $modelName }}(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    require.Nil(t, err)
    defer mockDB.Close()
    exampleID := uint64(1)
    expected := &models.{{ $modelName }}{ID: exampleID}
    client := NewPostgres()

    t.Run("optimal behavior", func(t *testing.T) {
        set{{ $modelName }}ReadQueryExpectation(t, mock, exampleID, expected, nil)
        actual, err := client.Get{{ $modelName }}(mockDB, exampleID)

        require.Nil(t, err)
        require.Equal(t, expected, actual, "expected {{ toLower $modelName }} did not match actual {{ toLower $modelName }}")
        require.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}

{{ $creationColumns := .Table.Columns.Names.Except (makeSlice "id" "created_on" "archived_on" "updated_on") -}}
func set{{ $modelName }}CreationQueryExpectation(t *testing.T, mock sqlmock.Sqlmock, toCreate *models.{{ $modelName }}, err error) {
    t.Helper()
    query := formatQueryForSQLMock({{ $creationQueryVarName }})
    exampleRows := sqlmock.NewRows([]string{"id", "created_on"{{- if $isProduct }}, "available_on"{{ end }}}).AddRow(uint64(1), generateExampleTimeForTests(t){{- if $isProduct }}, generateExampleTimeForTests(t){{ end }})
    mock.ExpectQuery(query).
        WithArgs(
            {{ $lastCol := dec (len $creationColumns) -}}
            {{ range $x, $col := $creationColumns -}}
            toCreate.{{ if or (eq (toLower $col) "sku") (eq (toLower $col) "upc") }}{{ toUpper $col }}{{ else }}{{ pascal $col }}{{ end }},
            {{ end }}
        ).
        WillReturnRows(exampleRows).
        WillReturnError(err)
}

func TestCreate{{ $modelName }}(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    require.Nil(t, err)
    defer mockDB.Close()
    expectedID := uint64(1)
    exampleInput := &models.{{ $modelName }}{ID: expectedID}
        client := NewPostgres()

    t.Run("optimal behavior", func(t *testing.T) {
        set{{ $modelName }}CreationQueryExpectation(t, mock, exampleInput, nil)
        expected := generateExampleTimeForTests(t)
        actualID, actualCreationDate,{{- if $isProduct }} actualAvailableOn, {{ end }}err := client.Create{{ $modelName }}(mockDB, exampleInput)

        require.Nil(t, err)
        require.Equal(t, expectedID, actualID, "expected and actual IDs don't match")
        require.Equal(t, expected, actualCreationDate, "expected creation time did not match actual creation time")
        {{ if $isProduct -}}require.Equal(t, expected, actualAvailableOn, "expected availability time did not match actual availability time"){{ end }}
        require.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}


{{ $updateColumns := .Table.Columns.Names.Except (makeSlice "id" "created_on" "archived_on") -}}
func set{{ $modelName }}UpdateQueryExpectation(t *testing.T, mock sqlmock.Sqlmock, toUpdate *models.{{ $modelName }}, err error) {
    t.Helper()
    query := formatQueryForSQLMock({{ $updateQueryVarName }})
    exampleRows := sqlmock.NewRows([]string{"updated_on"}).AddRow(generateExampleTimeForTests(t))
    mock.ExpectQuery(query).
        WithArgs(
            {{ $lastCol := dec (len $updateColumns) -}}
            {{ range $x, $col := $updateColumns -}}
            {{ if eq $col "updated_on"}}{{ else }}toUpdate.{{ if or (eq (toLower $col) "sku") (eq (toLower $col) "upc") }}{{ toUpper $col }}{{ else }}{{ pascal $col }}{{ end }},
            {{ end }}{{ end }}toUpdate.ID,
        ).
        WillReturnRows(exampleRows).
        WillReturnError(err)
}

func TestUpdate{{ $modelName }}ByID(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    require.Nil(t, err)
    defer mockDB.Close()
    exampleInput := &models.{{ $modelName }}{ID: uint64(1)}
    client := NewPostgres()

    t.Run("optimal behavior", func(t *testing.T) {
        set{{ $modelName }}UpdateQueryExpectation(t, mock, exampleInput, nil)
        expected := generateExampleTimeForTests(t)
        actual, err := client.Update{{ $modelName }}(mockDB, exampleInput)

        require.Nil(t, err)
        require.Equal(t, expected, actual, "expected deletion time did not match actual deletion time")
        require.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}


func set{{ $modelName }}DeletionQueryExpectation(t *testing.T, mock sqlmock.Sqlmock, id uint64, err error) {
    t.Helper()
    query := formatQueryForSQLMock({{ $deletionQueryVarName }})
    exampleRows := sqlmock.NewRows([]string{"archived_on"}).AddRow(generateExampleTimeForTests(t))
    mock.ExpectQuery(query).WithArgs(id).WillReturnRows(exampleRows).WillReturnError(err)
}

func TestDelete{{ $modelName }}ByID(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    require.Nil(t, err)
    defer mockDB.Close()
    exampleID := uint64(1)
    client := NewPostgres()

    t.Run("optimal behavior", func(t *testing.T) {
        set{{ $modelName }}DeletionQueryExpectation(t, mock, exampleID, nil)
        expected := generateExampleTimeForTests(t)
        actual, err := client.Delete{{ $modelName }}(mockDB, exampleID)

        require.Nil(t, err)
        require.Equal(t, expected, actual, "expected deletion time did not match actual deletion time")
        require.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })

    t.Run("with transaction", func(t *testing.T) {
        mock.ExpectBegin()
        set{{ $modelName }}DeletionQueryExpectation(t, mock, exampleID, nil)
        expected := generateExampleTimeForTests(t)
        tx, err := mockDB.Begin()
        require.Nil(t, err, "no error should be returned setting up a transaction in the mock DB")
        actual, err := client.Delete{{ $modelName }}(tx, exampleID)

        require.Nil(t, err)
        require.Equal(t, expected, actual, "expected deletion time did not match actual deletion time")
        require.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}

{{ if $isProductVariantBridge }}
{{ $pvbDeletionQueryVarName := printf "%sDeletionQueryByProductID" ( camel $modelName ) -}}

func set{{ $modelName }}DeletionByProductIDQueryExpectation(t *testing.T, mock sqlmock.Sqlmock, id uint64, err error) {
    t.Helper()
    query := formatQueryForSQLMock({{ $pvbDeletionQueryVarName }})
    exampleRows := sqlmock.NewRows([]string{"archived_on"}).AddRow(generateExampleTimeForTests(t))
    mock.ExpectQuery(query).WithArgs(id).WillReturnRows(exampleRows).WillReturnError(err)
}

func TestDelete{{ $modelName }}ByProductID(t *testing.T) {
    t.Parallel()
	mockDB, mock, err := sqlmock.New()
    require.Nil(t, err)
    defer mockDB.Close()
    exampleID := uint64(1)
    client := NewPostgres()

    t.Run("optimal behavior", func(t *testing.T) {
        set{{ $modelName }}DeletionByProductIDQueryExpectation(t, mock, exampleID, nil)
        expected := generateExampleTimeForTests(t)
        actual, err := client.Delete{{ $modelName }}ByProductID(mockDB, exampleID)

        require.Nil(t, err)
        require.Equal(t, expected, actual, "expected deletion time did not match actual deletion time")
        require.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })

    t.Run("with transaction", func(t *testing.T) {
        mock.ExpectBegin()
        set{{ $modelName }}DeletionByProductIDQueryExpectation(t, mock, exampleID, nil)
        expected := generateExampleTimeForTests(t)
        tx, err := mockDB.Begin()
        require.Nil(t, err, "no error should be returned setting up a transaction in the mock DB")
        actual, err := client.Delete{{ $modelName }}ByProductID(tx, exampleID)

        require.Nil(t, err)
        require.Equal(t, expected, actual, "expected deletion time did not match actual deletion time")
        require.Nil(t, mock.ExpectationsWereMet(), "not all database expectations were met")
    })
}
{{- end }}